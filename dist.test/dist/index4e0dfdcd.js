/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/zepto-webpack/zepto.js":
/*!*********************************************!*\
  !*** ./node_modules/zepto-webpack/zepto.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/* Zepto v1.2.0 - zepto event ajax form ie - zeptojs.com/license */\n(function(global, factory) {\n  if (true)\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return factory(global) }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  else\n    {}\n}(this, function() {\n  var Zepto = (function() {\n  var undefined, key, $, classList, emptyArray = [], concat = emptyArray.concat, filter = emptyArray.filter, slice = emptyArray.slice,\n    document = window.document,\n    elementDisplay = {}, classCache = {},\n    cssNumber = { 'column-count': 1, 'columns': 1, 'font-weight': 1, 'line-height': 1,'opacity': 1, 'z-index': 1, 'zoom': 1 },\n    fragmentRE = /^\\s*<(\\w+|!)[^>]*>/,\n    singleTagRE = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,\n    tagExpanderRE = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/ig,\n    rootNodeRE = /^(?:body|html)$/i,\n    capitalRE = /([A-Z])/g,\n\n    // special attributes that should be get/set via method calls\n    methodAttributes = ['val', 'css', 'html', 'text', 'data', 'width', 'height', 'offset'],\n\n    adjacencyOperators = [ 'after', 'prepend', 'before', 'append' ],\n    table = document.createElement('table'),\n    tableRow = document.createElement('tr'),\n    containers = {\n      'tr': document.createElement('tbody'),\n      'tbody': table, 'thead': table, 'tfoot': table,\n      'td': tableRow, 'th': tableRow,\n      '*': document.createElement('div')\n    },\n    readyRE = /complete|loaded|interactive/,\n    simpleSelectorRE = /^[\\w-]*$/,\n    class2type = {},\n    toString = class2type.toString,\n    zepto = {},\n    camelize, uniq,\n    tempParent = document.createElement('div'),\n    propMap = {\n      'tabindex': 'tabIndex',\n      'readonly': 'readOnly',\n      'for': 'htmlFor',\n      'class': 'className',\n      'maxlength': 'maxLength',\n      'cellspacing': 'cellSpacing',\n      'cellpadding': 'cellPadding',\n      'rowspan': 'rowSpan',\n      'colspan': 'colSpan',\n      'usemap': 'useMap',\n      'frameborder': 'frameBorder',\n      'contenteditable': 'contentEditable'\n    },\n    isArray = Array.isArray ||\n      function(object){ return object instanceof Array }\n\n  zepto.matches = function(element, selector) {\n    if (!selector || !element || element.nodeType !== 1) return false\n    var matchesSelector = element.matches || element.webkitMatchesSelector ||\n                          element.mozMatchesSelector || element.oMatchesSelector ||\n                          element.matchesSelector\n    if (matchesSelector) return matchesSelector.call(element, selector)\n    // fall back to performing a selector:\n    var match, parent = element.parentNode, temp = !parent\n    if (temp) (parent = tempParent).appendChild(element)\n    match = ~zepto.qsa(parent, selector).indexOf(element)\n    temp && tempParent.removeChild(element)\n    return match\n  }\n\n  function type(obj) {\n    return obj == null ? String(obj) :\n      class2type[toString.call(obj)] || \"object\"\n  }\n\n  function isFunction(value) { return type(value) == \"function\" }\n  function isWindow(obj)     { return obj != null && obj == obj.window }\n  function isDocument(obj)   { return obj != null && obj.nodeType == obj.DOCUMENT_NODE }\n  function isObject(obj)     { return type(obj) == \"object\" }\n  function isPlainObject(obj) {\n    return isObject(obj) && !isWindow(obj) && Object.getPrototypeOf(obj) == Object.prototype\n  }\n\n  function likeArray(obj) {\n    var length = !!obj && 'length' in obj && obj.length,\n      type = $.type(obj)\n\n    return 'function' != type && !isWindow(obj) && (\n      'array' == type || length === 0 ||\n        (typeof length == 'number' && length > 0 && (length - 1) in obj)\n    )\n  }\n\n  function compact(array) { return filter.call(array, function(item){ return item != null }) }\n  function flatten(array) { return array.length > 0 ? $.fn.concat.apply([], array) : array }\n  camelize = function(str){ return str.replace(/-+(.)?/g, function(match, chr){ return chr ? chr.toUpperCase() : '' }) }\n  function dasherize(str) {\n    return str.replace(/::/g, '/')\n           .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')\n           .replace(/([a-z\\d])([A-Z])/g, '$1_$2')\n           .replace(/_/g, '-')\n           .toLowerCase()\n  }\n  uniq = function(array){ return filter.call(array, function(item, idx){ return array.indexOf(item) == idx }) }\n\n  function classRE(name) {\n    return name in classCache ?\n      classCache[name] : (classCache[name] = new RegExp('(^|\\\\s)' + name + '(\\\\s|$)'))\n  }\n\n  function maybeAddPx(name, value) {\n    return (typeof value == \"number\" && !cssNumber[dasherize(name)]) ? value + \"px\" : value\n  }\n\n  function defaultDisplay(nodeName) {\n    var element, display\n    if (!elementDisplay[nodeName]) {\n      element = document.createElement(nodeName)\n      document.body.appendChild(element)\n      display = getComputedStyle(element, '').getPropertyValue(\"display\")\n      element.parentNode.removeChild(element)\n      display == \"none\" && (display = \"block\")\n      elementDisplay[nodeName] = display\n    }\n    return elementDisplay[nodeName]\n  }\n\n  function children(element) {\n    return 'children' in element ?\n      slice.call(element.children) :\n      $.map(element.childNodes, function(node){ if (node.nodeType == 1) return node })\n  }\n\n  function Z(dom, selector) {\n    var i, len = dom ? dom.length : 0\n    for (i = 0; i < len; i++) this[i] = dom[i]\n    this.length = len\n    this.selector = selector || ''\n  }\n\n  // `$.zepto.fragment` takes a html string and an optional tag name\n  // to generate DOM nodes from the given html string.\n  // The generated DOM nodes are returned as an array.\n  // This function can be overridden in plugins for example to make\n  // it compatible with browsers that don't support the DOM fully.\n  zepto.fragment = function(html, name, properties) {\n    var dom, nodes, container\n\n    // A special case optimization for a single tag\n    if (singleTagRE.test(html)) dom = $(document.createElement(RegExp.$1))\n\n    if (!dom) {\n      if (html.replace) html = html.replace(tagExpanderRE, \"<$1></$2>\")\n      if (name === undefined) name = fragmentRE.test(html) && RegExp.$1\n      if (!(name in containers)) name = '*'\n\n      container = containers[name]\n      container.innerHTML = '' + html\n      dom = $.each(slice.call(container.childNodes), function(){\n        container.removeChild(this)\n      })\n    }\n\n    if (isPlainObject(properties)) {\n      nodes = $(dom)\n      $.each(properties, function(key, value) {\n        if (methodAttributes.indexOf(key) > -1) nodes[key](value)\n        else nodes.attr(key, value)\n      })\n    }\n\n    return dom\n  }\n\n  // `$.zepto.Z` swaps out the prototype of the given `dom` array\n  // of nodes with `$.fn` and thus supplying all the Zepto functions\n  // to the array. This method can be overridden in plugins.\n  zepto.Z = function(dom, selector) {\n    return new Z(dom, selector)\n  }\n\n  // `$.zepto.isZ` should return `true` if the given object is a Zepto\n  // collection. This method can be overridden in plugins.\n  zepto.isZ = function(object) {\n    return object instanceof zepto.Z\n  }\n\n  // `$.zepto.init` is Zepto's counterpart to jQuery's `$.fn.init` and\n  // takes a CSS selector and an optional context (and handles various\n  // special cases).\n  // This method can be overridden in plugins.\n  zepto.init = function(selector, context) {\n    var dom\n    // If nothing given, return an empty Zepto collection\n    if (!selector) return zepto.Z()\n    // Optimize for string selectors\n    else if (typeof selector == 'string') {\n      selector = selector.trim()\n      // If it's a html fragment, create nodes from it\n      // Note: In both Chrome 21 and Firefox 15, DOM error 12\n      // is thrown if the fragment doesn't begin with <\n      if (selector[0] == '<' && fragmentRE.test(selector))\n        dom = zepto.fragment(selector, RegExp.$1, context), selector = null\n      // If there's a context, create a collection on that context first, and select\n      // nodes from there\n      else if (context !== undefined) return $(context).find(selector)\n      // If it's a CSS selector, use it to select nodes.\n      else dom = zepto.qsa(document, selector)\n    }\n    // If a function is given, call it when the DOM is ready\n    else if (isFunction(selector)) return $(document).ready(selector)\n    // If a Zepto collection is given, just return it\n    else if (zepto.isZ(selector)) return selector\n    else {\n      // normalize array if an array of nodes is given\n      if (isArray(selector)) dom = compact(selector)\n      // Wrap DOM nodes.\n      else if (isObject(selector))\n        dom = [selector], selector = null\n      // If it's a html fragment, create nodes from it\n      else if (fragmentRE.test(selector))\n        dom = zepto.fragment(selector.trim(), RegExp.$1, context), selector = null\n      // If there's a context, create a collection on that context first, and select\n      // nodes from there\n      else if (context !== undefined) return $(context).find(selector)\n      // And last but no least, if it's a CSS selector, use it to select nodes.\n      else dom = zepto.qsa(document, selector)\n    }\n    // create a new Zepto collection from the nodes found\n    return zepto.Z(dom, selector)\n  }\n\n  // `$` will be the base `Zepto` object. When calling this\n  // function just call `$.zepto.init, which makes the implementation\n  // details of selecting nodes and creating Zepto collections\n  // patchable in plugins.\n  $ = function(selector, context){\n    return zepto.init(selector, context)\n  }\n\n  function extend(target, source, deep) {\n    for (key in source)\n      if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {\n        if (isPlainObject(source[key]) && !isPlainObject(target[key]))\n          target[key] = {}\n        if (isArray(source[key]) && !isArray(target[key]))\n          target[key] = []\n        extend(target[key], source[key], deep)\n      }\n      else if (source[key] !== undefined) target[key] = source[key]\n  }\n\n  // Copy all but undefined properties from one or more\n  // objects to the `target` object.\n  $.extend = function(target){\n    var deep, args = slice.call(arguments, 1)\n    if (typeof target == 'boolean') {\n      deep = target\n      target = args.shift()\n    }\n    args.forEach(function(arg){ extend(target, arg, deep) })\n    return target\n  }\n\n  // `$.zepto.qsa` is Zepto's CSS selector implementation which\n  // uses `document.querySelectorAll` and optimizes for some special cases, like `#id`.\n  // This method can be overridden in plugins.\n  zepto.qsa = function(element, selector){\n    var found,\n        maybeID = selector[0] == '#',\n        maybeClass = !maybeID && selector[0] == '.',\n        nameOnly = maybeID || maybeClass ? selector.slice(1) : selector, // Ensure that a 1 char tag name still gets checked\n        isSimple = simpleSelectorRE.test(nameOnly)\n    return (element.getElementById && isSimple && maybeID) ? // Safari DocumentFragment doesn't have getElementById\n      ( (found = element.getElementById(nameOnly)) ? [found] : [] ) :\n      (element.nodeType !== 1 && element.nodeType !== 9 && element.nodeType !== 11) ? [] :\n      slice.call(\n        isSimple && !maybeID && element.getElementsByClassName ? // DocumentFragment doesn't have getElementsByClassName/TagName\n          maybeClass ? element.getElementsByClassName(nameOnly) : // If it's simple, it could be a class\n          element.getElementsByTagName(selector) : // Or a tag\n          element.querySelectorAll(selector) // Or it's not simple, and we need to query all\n      )\n  }\n\n  function filtered(nodes, selector) {\n    return selector == null ? $(nodes) : $(nodes).filter(selector)\n  }\n\n  $.contains = document.documentElement.contains ?\n    function(parent, node) {\n      return parent !== node && parent.contains(node)\n    } :\n    function(parent, node) {\n      while (node && (node = node.parentNode))\n        if (node === parent) return true\n      return false\n    }\n\n  function funcArg(context, arg, idx, payload) {\n    return isFunction(arg) ? arg.call(context, idx, payload) : arg\n  }\n\n  function setAttribute(node, name, value) {\n    value == null ? node.removeAttribute(name) : node.setAttribute(name, value)\n  }\n\n  // access className property while respecting SVGAnimatedString\n  function className(node, value){\n    var klass = node.className || '',\n        svg   = klass && klass.baseVal !== undefined\n\n    if (value === undefined) return svg ? klass.baseVal : klass\n    svg ? (klass.baseVal = value) : (node.className = value)\n  }\n\n  // \"true\"  => true\n  // \"false\" => false\n  // \"null\"  => null\n  // \"42\"    => 42\n  // \"42.5\"  => 42.5\n  // \"08\"    => \"08\"\n  // JSON    => parse if valid\n  // String  => self\n  function deserializeValue(value) {\n    try {\n      return value ?\n        value == \"true\" ||\n        ( value == \"false\" ? false :\n          value == \"null\" ? null :\n          +value + \"\" == value ? +value :\n          /^[\\[\\{]/.test(value) ? $.parseJSON(value) :\n          value )\n        : value\n    } catch(e) {\n      return value\n    }\n  }\n\n  $.type = type\n  $.isFunction = isFunction\n  $.isWindow = isWindow\n  $.isArray = isArray\n  $.isPlainObject = isPlainObject\n\n  $.isEmptyObject = function(obj) {\n    var name\n    for (name in obj) return false\n    return true\n  }\n\n  $.isNumeric = function(val) {\n    var num = Number(val), type = typeof val\n    return val != null && type != 'boolean' &&\n      (type != 'string' || val.length) &&\n      !isNaN(num) && isFinite(num) || false\n  }\n\n  $.inArray = function(elem, array, i){\n    return emptyArray.indexOf.call(array, elem, i)\n  }\n\n  $.camelCase = camelize\n  $.trim = function(str) {\n    return str == null ? \"\" : String.prototype.trim.call(str)\n  }\n\n  // plugin compatibility\n  $.uuid = 0\n  $.support = { }\n  $.expr = { }\n  $.noop = function() {}\n\n  $.map = function(elements, callback){\n    var value, values = [], i, key\n    if (likeArray(elements))\n      for (i = 0; i < elements.length; i++) {\n        value = callback(elements[i], i)\n        if (value != null) values.push(value)\n      }\n    else\n      for (key in elements) {\n        value = callback(elements[key], key)\n        if (value != null) values.push(value)\n      }\n    return flatten(values)\n  }\n\n  $.each = function(elements, callback){\n    var i, key\n    if (likeArray(elements)) {\n      for (i = 0; i < elements.length; i++)\n        if (callback.call(elements[i], i, elements[i]) === false) return elements\n    } else {\n      for (key in elements)\n        if (callback.call(elements[key], key, elements[key]) === false) return elements\n    }\n\n    return elements\n  }\n\n  $.grep = function(elements, callback){\n    return filter.call(elements, callback)\n  }\n\n  if (window.JSON) $.parseJSON = JSON.parse\n\n  // Populate the class2type map\n  $.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(i, name) {\n    class2type[ \"[object \" + name + \"]\" ] = name.toLowerCase()\n  })\n\n  // Define methods that will be available on all\n  // Zepto collections\n  $.fn = {\n    constructor: zepto.Z,\n    length: 0,\n\n    // Because a collection acts like an array\n    // copy over these useful array functions.\n    forEach: emptyArray.forEach,\n    reduce: emptyArray.reduce,\n    push: emptyArray.push,\n    sort: emptyArray.sort,\n    splice: emptyArray.splice,\n    indexOf: emptyArray.indexOf,\n    concat: function(){\n      var i, value, args = []\n      for (i = 0; i < arguments.length; i++) {\n        value = arguments[i]\n        args[i] = zepto.isZ(value) ? value.toArray() : value\n      }\n      return concat.apply(zepto.isZ(this) ? this.toArray() : this, args)\n    },\n\n    // `map` and `slice` in the jQuery API work differently\n    // from their array counterparts\n    map: function(fn){\n      return $($.map(this, function(el, i){ return fn.call(el, i, el) }))\n    },\n    slice: function(){\n      return $(slice.apply(this, arguments))\n    },\n\n    ready: function(callback){\n      // need to check if document.body exists for IE as that browser reports\n      // document ready when it hasn't yet created the body element\n      if (readyRE.test(document.readyState) && document.body) callback($)\n      else document.addEventListener('DOMContentLoaded', function(){ callback($) }, false)\n      return this\n    },\n    get: function(idx){\n      return idx === undefined ? slice.call(this) : this[idx >= 0 ? idx : idx + this.length]\n    },\n    toArray: function(){ return this.get() },\n    size: function(){\n      return this.length\n    },\n    remove: function(){\n      return this.each(function(){\n        if (this.parentNode != null)\n          this.parentNode.removeChild(this)\n      })\n    },\n    each: function(callback){\n      emptyArray.every.call(this, function(el, idx){\n        return callback.call(el, idx, el) !== false\n      })\n      return this\n    },\n    filter: function(selector){\n      if (isFunction(selector)) return this.not(this.not(selector))\n      return $(filter.call(this, function(element){\n        return zepto.matches(element, selector)\n      }))\n    },\n    add: function(selector,context){\n      return $(uniq(this.concat($(selector,context))))\n    },\n    is: function(selector){\n      return this.length > 0 && zepto.matches(this[0], selector)\n    },\n    not: function(selector){\n      var nodes=[]\n      if (isFunction(selector) && selector.call !== undefined)\n        this.each(function(idx){\n          if (!selector.call(this,idx)) nodes.push(this)\n        })\n      else {\n        var excludes = typeof selector == 'string' ? this.filter(selector) :\n          (likeArray(selector) && isFunction(selector.item)) ? slice.call(selector) : $(selector)\n        this.forEach(function(el){\n          if (excludes.indexOf(el) < 0) nodes.push(el)\n        })\n      }\n      return $(nodes)\n    },\n    has: function(selector){\n      return this.filter(function(){\n        return isObject(selector) ?\n          $.contains(this, selector) :\n          $(this).find(selector).size()\n      })\n    },\n    eq: function(idx){\n      return idx === -1 ? this.slice(idx) : this.slice(idx, + idx + 1)\n    },\n    first: function(){\n      var el = this[0]\n      return el && !isObject(el) ? el : $(el)\n    },\n    last: function(){\n      var el = this[this.length - 1]\n      return el && !isObject(el) ? el : $(el)\n    },\n    find: function(selector){\n      var result, $this = this\n      if (!selector) result = $()\n      else if (typeof selector == 'object')\n        result = $(selector).filter(function(){\n          var node = this\n          return emptyArray.some.call($this, function(parent){\n            return $.contains(parent, node)\n          })\n        })\n      else if (this.length == 1) result = $(zepto.qsa(this[0], selector))\n      else result = this.map(function(){ return zepto.qsa(this, selector) })\n      return result\n    },\n    closest: function(selector, context){\n      var nodes = [], collection = typeof selector == 'object' && $(selector)\n      this.each(function(_, node){\n        while (node && !(collection ? collection.indexOf(node) >= 0 : zepto.matches(node, selector)))\n          node = node !== context && !isDocument(node) && node.parentNode\n        if (node && nodes.indexOf(node) < 0) nodes.push(node)\n      })\n      return $(nodes)\n    },\n    parents: function(selector){\n      var ancestors = [], nodes = this\n      while (nodes.length > 0)\n        nodes = $.map(nodes, function(node){\n          if ((node = node.parentNode) && !isDocument(node) && ancestors.indexOf(node) < 0) {\n            ancestors.push(node)\n            return node\n          }\n        })\n      return filtered(ancestors, selector)\n    },\n    parent: function(selector){\n      return filtered(uniq(this.pluck('parentNode')), selector)\n    },\n    children: function(selector){\n      return filtered(this.map(function(){ return children(this) }), selector)\n    },\n    contents: function() {\n      return this.map(function() { return this.contentDocument || slice.call(this.childNodes) })\n    },\n    siblings: function(selector){\n      return filtered(this.map(function(i, el){\n        return filter.call(children(el.parentNode), function(child){ return child!==el })\n      }), selector)\n    },\n    empty: function(){\n      return this.each(function(){ this.innerHTML = '' })\n    },\n    // `pluck` is borrowed from Prototype.js\n    pluck: function(property){\n      return $.map(this, function(el){ return el[property] })\n    },\n    show: function(){\n      return this.each(function(){\n        this.style.display == \"none\" && (this.style.display = '')\n        if (getComputedStyle(this, '').getPropertyValue(\"display\") == \"none\")\n          this.style.display = defaultDisplay(this.nodeName)\n      })\n    },\n    replaceWith: function(newContent){\n      return this.before(newContent).remove()\n    },\n    wrap: function(structure){\n      var func = isFunction(structure)\n      if (this[0] && !func)\n        var dom   = $(structure).get(0),\n            clone = dom.parentNode || this.length > 1\n\n      return this.each(function(index){\n        $(this).wrapAll(\n          func ? structure.call(this, index) :\n            clone ? dom.cloneNode(true) : dom\n        )\n      })\n    },\n    wrapAll: function(structure){\n      if (this[0]) {\n        $(this[0]).before(structure = $(structure))\n        var children\n        // drill down to the inmost element\n        while ((children = structure.children()).length) structure = children.first()\n        $(structure).append(this)\n      }\n      return this\n    },\n    wrapInner: function(structure){\n      var func = isFunction(structure)\n      return this.each(function(index){\n        var self = $(this), contents = self.contents(),\n            dom  = func ? structure.call(this, index) : structure\n        contents.length ? contents.wrapAll(dom) : self.append(dom)\n      })\n    },\n    unwrap: function(){\n      this.parent().each(function(){\n        $(this).replaceWith($(this).children())\n      })\n      return this\n    },\n    clone: function(){\n      return this.map(function(){ return this.cloneNode(true) })\n    },\n    hide: function(){\n      return this.css(\"display\", \"none\")\n    },\n    toggle: function(setting){\n      return this.each(function(){\n        var el = $(this)\n        ;(setting === undefined ? el.css(\"display\") == \"none\" : setting) ? el.show() : el.hide()\n      })\n    },\n    prev: function(selector){ return $(this.pluck('previousElementSibling')).filter(selector || '*') },\n    next: function(selector){ return $(this.pluck('nextElementSibling')).filter(selector || '*') },\n    html: function(html){\n      return 0 in arguments ?\n        this.each(function(idx){\n          var originHtml = this.innerHTML\n          $(this).empty().append( funcArg(this, html, idx, originHtml) )\n        }) :\n        (0 in this ? this[0].innerHTML : null)\n    },\n    text: function(text){\n      return 0 in arguments ?\n        this.each(function(idx){\n          var newText = funcArg(this, text, idx, this.textContent)\n          this.textContent = newText == null ? '' : ''+newText\n        }) :\n        (0 in this ? this.pluck('textContent').join(\"\") : null)\n    },\n    attr: function(name, value){\n      var result\n      return (typeof name == 'string' && !(1 in arguments)) ?\n        (0 in this && this[0].nodeType == 1 && (result = this[0].getAttribute(name)) != null ? result : undefined) :\n        this.each(function(idx){\n          if (this.nodeType !== 1) return\n          if (isObject(name)) for (key in name) setAttribute(this, key, name[key])\n          else setAttribute(this, name, funcArg(this, value, idx, this.getAttribute(name)))\n        })\n    },\n    removeAttr: function(name){\n      return this.each(function(){ this.nodeType === 1 && name.split(' ').forEach(function(attribute){\n        setAttribute(this, attribute)\n      }, this)})\n    },\n    prop: function(name, value){\n      name = propMap[name] || name\n      return (1 in arguments) ?\n        this.each(function(idx){\n          this[name] = funcArg(this, value, idx, this[name])\n        }) :\n        (this[0] && this[0][name])\n    },\n    removeProp: function(name){\n      name = propMap[name] || name\n      return this.each(function(){ delete this[name] })\n    },\n    data: function(name, value){\n      var attrName = 'data-' + name.replace(capitalRE, '-$1').toLowerCase()\n\n      var data = (1 in arguments) ?\n        this.attr(attrName, value) :\n        this.attr(attrName)\n\n      return data !== null ? deserializeValue(data) : undefined\n    },\n    val: function(value){\n      if (0 in arguments) {\n        if (value == null) value = \"\"\n        return this.each(function(idx){\n          this.value = funcArg(this, value, idx, this.value)\n        })\n      } else {\n        return this[0] && (this[0].multiple ?\n           $(this[0]).find('option').filter(function(){ return this.selected }).pluck('value') :\n           this[0].value)\n      }\n    },\n    offset: function(coordinates){\n      if (coordinates) return this.each(function(index){\n        var $this = $(this),\n            coords = funcArg(this, coordinates, index, $this.offset()),\n            parentOffset = $this.offsetParent().offset(),\n            props = {\n              top:  coords.top  - parentOffset.top,\n              left: coords.left - parentOffset.left\n            }\n\n        if ($this.css('position') == 'static') props['position'] = 'relative'\n        $this.css(props)\n      })\n      if (!this.length) return null\n      if (document.documentElement !== this[0] && !$.contains(document.documentElement, this[0]))\n        return {top: 0, left: 0}\n      var obj = this[0].getBoundingClientRect()\n      return {\n        left: obj.left + window.pageXOffset,\n        top: obj.top + window.pageYOffset,\n        width: Math.round(obj.width),\n        height: Math.round(obj.height)\n      }\n    },\n    css: function(property, value){\n      if (arguments.length < 2) {\n        var element = this[0]\n        if (typeof property == 'string') {\n          if (!element) return\n          return element.style[camelize(property)] || getComputedStyle(element, '').getPropertyValue(property)\n        } else if (isArray(property)) {\n          if (!element) return\n          var props = {}\n          var computedStyle = getComputedStyle(element, '')\n          $.each(property, function(_, prop){\n            props[prop] = (element.style[camelize(prop)] || computedStyle.getPropertyValue(prop))\n          })\n          return props\n        }\n      }\n\n      var css = ''\n      if (type(property) == 'string') {\n        if (!value && value !== 0)\n          this.each(function(){ this.style.removeProperty(dasherize(property)) })\n        else\n          css = dasherize(property) + \":\" + maybeAddPx(property, value)\n      } else {\n        for (key in property)\n          if (!property[key] && property[key] !== 0)\n            this.each(function(){ this.style.removeProperty(dasherize(key)) })\n          else\n            css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';'\n      }\n\n      return this.each(function(){ this.style.cssText += ';' + css })\n    },\n    index: function(element){\n      return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0])\n    },\n    hasClass: function(name){\n      if (!name) return false\n      return emptyArray.some.call(this, function(el){\n        return this.test(className(el))\n      }, classRE(name))\n    },\n    addClass: function(name){\n      if (!name) return this\n      return this.each(function(idx){\n        if (!('className' in this)) return\n        classList = []\n        var cls = className(this), newName = funcArg(this, name, idx, cls)\n        newName.split(/\\s+/g).forEach(function(klass){\n          if (!$(this).hasClass(klass)) classList.push(klass)\n        }, this)\n        classList.length && className(this, cls + (cls ? \" \" : \"\") + classList.join(\" \"))\n      })\n    },\n    removeClass: function(name){\n      return this.each(function(idx){\n        if (!('className' in this)) return\n        if (name === undefined) return className(this, '')\n        classList = className(this)\n        funcArg(this, name, idx, classList).split(/\\s+/g).forEach(function(klass){\n          classList = classList.replace(classRE(klass), \" \")\n        })\n        className(this, classList.trim())\n      })\n    },\n    toggleClass: function(name, when){\n      if (!name) return this\n      return this.each(function(idx){\n        var $this = $(this), names = funcArg(this, name, idx, className(this))\n        names.split(/\\s+/g).forEach(function(klass){\n          (when === undefined ? !$this.hasClass(klass) : when) ?\n            $this.addClass(klass) : $this.removeClass(klass)\n        })\n      })\n    },\n    scrollTop: function(value){\n      if (!this.length) return\n      var hasScrollTop = 'scrollTop' in this[0]\n      if (value === undefined) return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset\n      return this.each(hasScrollTop ?\n        function(){ this.scrollTop = value } :\n        function(){ this.scrollTo(this.scrollX, value) })\n    },\n    scrollLeft: function(value){\n      if (!this.length) return\n      var hasScrollLeft = 'scrollLeft' in this[0]\n      if (value === undefined) return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset\n      return this.each(hasScrollLeft ?\n        function(){ this.scrollLeft = value } :\n        function(){ this.scrollTo(value, this.scrollY) })\n    },\n    position: function() {\n      if (!this.length) return\n\n      var elem = this[0],\n        // Get *real* offsetParent\n        offsetParent = this.offsetParent(),\n        // Get correct offsets\n        offset       = this.offset(),\n        parentOffset = rootNodeRE.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset()\n\n      // Subtract element margins\n      // note: when an element has margin: auto the offsetLeft and marginLeft\n      // are the same in Safari causing offset.left to incorrectly be 0\n      offset.top  -= parseFloat( $(elem).css('margin-top') ) || 0\n      offset.left -= parseFloat( $(elem).css('margin-left') ) || 0\n\n      // Add offsetParent borders\n      parentOffset.top  += parseFloat( $(offsetParent[0]).css('border-top-width') ) || 0\n      parentOffset.left += parseFloat( $(offsetParent[0]).css('border-left-width') ) || 0\n\n      // Subtract the two offsets\n      return {\n        top:  offset.top  - parentOffset.top,\n        left: offset.left - parentOffset.left\n      }\n    },\n    offsetParent: function() {\n      return this.map(function(){\n        var parent = this.offsetParent || document.body\n        while (parent && !rootNodeRE.test(parent.nodeName) && $(parent).css(\"position\") == \"static\")\n          parent = parent.offsetParent\n        return parent\n      })\n    }\n  }\n\n  // for now\n  $.fn.detach = $.fn.remove\n\n  // Generate the `width` and `height` functions\n  ;['width', 'height'].forEach(function(dimension){\n    var dimensionProperty =\n      dimension.replace(/./, function(m){ return m[0].toUpperCase() })\n\n    $.fn[dimension] = function(value){\n      var offset, el = this[0]\n      if (value === undefined) return isWindow(el) ? el['inner' + dimensionProperty] :\n        isDocument(el) ? el.documentElement['scroll' + dimensionProperty] :\n        (offset = this.offset()) && offset[dimension]\n      else return this.each(function(idx){\n        el = $(this)\n        el.css(dimension, funcArg(this, value, idx, el[dimension]()))\n      })\n    }\n  })\n\n  function traverseNode(node, fun) {\n    fun(node)\n    for (var i = 0, len = node.childNodes.length; i < len; i++)\n      traverseNode(node.childNodes[i], fun)\n  }\n\n  // Generate the `after`, `prepend`, `before`, `append`,\n  // `insertAfter`, `insertBefore`, `appendTo`, and `prependTo` methods.\n  adjacencyOperators.forEach(function(operator, operatorIndex) {\n    var inside = operatorIndex % 2 //=> prepend, append\n\n    $.fn[operator] = function(){\n      // arguments can be nodes, arrays of nodes, Zepto objects and HTML strings\n      var argType, nodes = $.map(arguments, function(arg) {\n            var arr = []\n            argType = type(arg)\n            if (argType == \"array\") {\n              arg.forEach(function(el) {\n                if (el.nodeType !== undefined) return arr.push(el)\n                else if ($.zepto.isZ(el)) return arr = arr.concat(el.get())\n                arr = arr.concat(zepto.fragment(el))\n              })\n              return arr\n            }\n            return argType == \"object\" || arg == null ?\n              arg : zepto.fragment(arg)\n          }),\n          parent, copyByClone = this.length > 1\n      if (nodes.length < 1) return this\n\n      return this.each(function(_, target){\n        parent = inside ? target : target.parentNode\n\n        // convert all methods to a \"before\" operation\n        target = operatorIndex == 0 ? target.nextSibling :\n                 operatorIndex == 1 ? target.firstChild :\n                 operatorIndex == 2 ? target :\n                 null\n\n        var parentInDocument = $.contains(document.documentElement, parent)\n\n        nodes.forEach(function(node){\n          if (copyByClone) node = node.cloneNode(true)\n          else if (!parent) return $(node).remove()\n\n          parent.insertBefore(node, target)\n          if (parentInDocument) traverseNode(node, function(el){\n            if (el.nodeName != null && el.nodeName.toUpperCase() === 'SCRIPT' &&\n               (!el.type || el.type === 'text/javascript') && !el.src){\n              var target = el.ownerDocument ? el.ownerDocument.defaultView : window\n              target['eval'].call(target, el.innerHTML)\n            }\n          })\n        })\n      })\n    }\n\n    // after    => insertAfter\n    // prepend  => prependTo\n    // before   => insertBefore\n    // append   => appendTo\n    $.fn[inside ? operator+'To' : 'insert'+(operatorIndex ? 'Before' : 'After')] = function(html){\n      $(html)[operator](this)\n      return this\n    }\n  })\n\n  zepto.Z.prototype = Z.prototype = $.fn\n\n  // Export internal API functions in the `$.zepto` namespace\n  zepto.uniq = uniq\n  zepto.deserializeValue = deserializeValue\n  $.zepto = zepto\n\n  return $\n})()\n\nwindow.Zepto = Zepto\nwindow.$ === undefined && (window.$ = Zepto)\n    module.exports = Zepto\n    \n;(function($){\n  var _zid = 1, undefined,\n      slice = Array.prototype.slice,\n      isFunction = $.isFunction,\n      isString = function(obj){ return typeof obj == 'string' },\n      handlers = {},\n      specialEvents={},\n      focusinSupported = 'onfocusin' in window,\n      focus = { focus: 'focusin', blur: 'focusout' },\n      hover = { mouseenter: 'mouseover', mouseleave: 'mouseout' }\n\n  specialEvents.click = specialEvents.mousedown = specialEvents.mouseup = specialEvents.mousemove = 'MouseEvents'\n\n  function zid(element) {\n    return element._zid || (element._zid = _zid++)\n  }\n  function findHandlers(element, event, fn, selector) {\n    event = parse(event)\n    if (event.ns) var matcher = matcherFor(event.ns)\n    return (handlers[zid(element)] || []).filter(function(handler) {\n      return handler\n        && (!event.e  || handler.e == event.e)\n        && (!event.ns || matcher.test(handler.ns))\n        && (!fn       || zid(handler.fn) === zid(fn))\n        && (!selector || handler.sel == selector)\n    })\n  }\n  function parse(event) {\n    var parts = ('' + event).split('.')\n    return {e: parts[0], ns: parts.slice(1).sort().join(' ')}\n  }\n  function matcherFor(ns) {\n    return new RegExp('(?:^| )' + ns.replace(' ', ' .* ?') + '(?: |$)')\n  }\n\n  function eventCapture(handler, captureSetting) {\n    return handler.del &&\n      (!focusinSupported && (handler.e in focus)) ||\n      !!captureSetting\n  }\n\n  function realEvent(type) {\n    return hover[type] || (focusinSupported && focus[type]) || type\n  }\n\n  function add(element, events, fn, data, selector, delegator, capture){\n    var id = zid(element), set = (handlers[id] || (handlers[id] = []))\n    events.split(/\\s/).forEach(function(event){\n      if (event == 'ready') return $(document).ready(fn)\n      var handler   = parse(event)\n      handler.fn    = fn\n      handler.sel   = selector\n      // emulate mouseenter, mouseleave\n      if (handler.e in hover) fn = function(e){\n        var related = e.relatedTarget\n        if (!related || (related !== this && !$.contains(this, related)))\n          return handler.fn.apply(this, arguments)\n      }\n      handler.del   = delegator\n      var callback  = delegator || fn\n      handler.proxy = function(e){\n        e = compatible(e)\n        if (e.isImmediatePropagationStopped()) return\n        e.data = data\n        var result = callback.apply(element, e._args == undefined ? [e] : [e].concat(e._args))\n        if (result === false) e.preventDefault(), e.stopPropagation()\n        return result\n      }\n      handler.i = set.length\n      set.push(handler)\n      if ('addEventListener' in element)\n        element.addEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))\n    })\n  }\n  function remove(element, events, fn, selector, capture){\n    var id = zid(element)\n    ;(events || '').split(/\\s/).forEach(function(event){\n      findHandlers(element, event, fn, selector).forEach(function(handler){\n        delete handlers[id][handler.i]\n      if ('removeEventListener' in element)\n        element.removeEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))\n      })\n    })\n  }\n\n  $.event = { add: add, remove: remove }\n\n  $.proxy = function(fn, context) {\n    var args = (2 in arguments) && slice.call(arguments, 2)\n    if (isFunction(fn)) {\n      var proxyFn = function(){ return fn.apply(context, args ? args.concat(slice.call(arguments)) : arguments) }\n      proxyFn._zid = zid(fn)\n      return proxyFn\n    } else if (isString(context)) {\n      if (args) {\n        args.unshift(fn[context], fn)\n        return $.proxy.apply(null, args)\n      } else {\n        return $.proxy(fn[context], fn)\n      }\n    } else {\n      throw new TypeError(\"expected function\")\n    }\n  }\n\n  $.fn.bind = function(event, data, callback){\n    return this.on(event, data, callback)\n  }\n  $.fn.unbind = function(event, callback){\n    return this.off(event, callback)\n  }\n  $.fn.one = function(event, selector, data, callback){\n    return this.on(event, selector, data, callback, 1)\n  }\n\n  var returnTrue = function(){return true},\n      returnFalse = function(){return false},\n      ignoreProperties = /^([A-Z]|returnValue$|layer[XY]$|webkitMovement[XY]$)/,\n      eventMethods = {\n        preventDefault: 'isDefaultPrevented',\n        stopImmediatePropagation: 'isImmediatePropagationStopped',\n        stopPropagation: 'isPropagationStopped'\n      }\n\n  function compatible(event, source) {\n    if (source || !event.isDefaultPrevented) {\n      source || (source = event)\n\n      $.each(eventMethods, function(name, predicate) {\n        var sourceMethod = source[name]\n        event[name] = function(){\n          this[predicate] = returnTrue\n          return sourceMethod && sourceMethod.apply(source, arguments)\n        }\n        event[predicate] = returnFalse\n      })\n\n      event.timeStamp || (event.timeStamp = Date.now())\n\n      if (source.defaultPrevented !== undefined ? source.defaultPrevented :\n          'returnValue' in source ? source.returnValue === false :\n          source.getPreventDefault && source.getPreventDefault())\n        event.isDefaultPrevented = returnTrue\n    }\n    return event\n  }\n\n  function createProxy(event) {\n    var key, proxy = { originalEvent: event }\n    for (key in event)\n      if (!ignoreProperties.test(key) && event[key] !== undefined) proxy[key] = event[key]\n\n    return compatible(proxy, event)\n  }\n\n  $.fn.delegate = function(selector, event, callback){\n    return this.on(event, selector, callback)\n  }\n  $.fn.undelegate = function(selector, event, callback){\n    return this.off(event, selector, callback)\n  }\n\n  $.fn.live = function(event, callback){\n    $(document.body).delegate(this.selector, event, callback)\n    return this\n  }\n  $.fn.die = function(event, callback){\n    $(document.body).undelegate(this.selector, event, callback)\n    return this\n  }\n\n  $.fn.on = function(event, selector, data, callback, one){\n    var autoRemove, delegator, $this = this\n    if (event && !isString(event)) {\n      $.each(event, function(type, fn){\n        $this.on(type, selector, data, fn, one)\n      })\n      return $this\n    }\n\n    if (!isString(selector) && !isFunction(callback) && callback !== false)\n      callback = data, data = selector, selector = undefined\n    if (callback === undefined || data === false)\n      callback = data, data = undefined\n\n    if (callback === false) callback = returnFalse\n\n    return $this.each(function(_, element){\n      if (one) autoRemove = function(e){\n        remove(element, e.type, callback)\n        return callback.apply(this, arguments)\n      }\n\n      if (selector) delegator = function(e){\n        var evt, match = $(e.target).closest(selector, element).get(0)\n        if (match && match !== element) {\n          evt = $.extend(createProxy(e), {currentTarget: match, liveFired: element})\n          return (autoRemove || callback).apply(match, [evt].concat(slice.call(arguments, 1)))\n        }\n      }\n\n      add(element, event, callback, data, selector, delegator || autoRemove)\n    })\n  }\n  $.fn.off = function(event, selector, callback){\n    var $this = this\n    if (event && !isString(event)) {\n      $.each(event, function(type, fn){\n        $this.off(type, selector, fn)\n      })\n      return $this\n    }\n\n    if (!isString(selector) && !isFunction(callback) && callback !== false)\n      callback = selector, selector = undefined\n\n    if (callback === false) callback = returnFalse\n\n    return $this.each(function(){\n      remove(this, event, callback, selector)\n    })\n  }\n\n  $.fn.trigger = function(event, args){\n    event = (isString(event) || $.isPlainObject(event)) ? $.Event(event) : compatible(event)\n    event._args = args\n    return this.each(function(){\n      // handle focus(), blur() by calling them directly\n      if (event.type in focus && typeof this[event.type] == \"function\") this[event.type]()\n      // items in the collection might not be DOM elements\n      else if ('dispatchEvent' in this) this.dispatchEvent(event)\n      else $(this).triggerHandler(event, args)\n    })\n  }\n\n  // triggers event handlers on current element just as if an event occurred,\n  // doesn't trigger an actual event, doesn't bubble\n  $.fn.triggerHandler = function(event, args){\n    var e, result\n    this.each(function(i, element){\n      e = createProxy(isString(event) ? $.Event(event) : event)\n      e._args = args\n      e.target = element\n      $.each(findHandlers(element, event.type || event), function(i, handler){\n        result = handler.proxy(e)\n        if (e.isImmediatePropagationStopped()) return false\n      })\n    })\n    return result\n  }\n\n  // shortcut methods for `.bind(event, fn)` for each event type\n  ;('focusin focusout focus blur load resize scroll unload click dblclick '+\n  'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave '+\n  'change select keydown keypress keyup error').split(' ').forEach(function(event) {\n    $.fn[event] = function(callback) {\n      return (0 in arguments) ?\n        this.bind(event, callback) :\n        this.trigger(event)\n    }\n  })\n\n  $.Event = function(type, props) {\n    if (!isString(type)) props = type, type = props.type\n    var event = document.createEvent(specialEvents[type] || 'Events'), bubbles = true\n    if (props) for (var name in props) (name == 'bubbles') ? (bubbles = !!props[name]) : (event[name] = props[name])\n    event.initEvent(type, bubbles, true)\n    return compatible(event)\n  }\n\n})(Zepto)\n\n;(function($){\n  var jsonpID = +new Date(),\n      document = window.document,\n      key,\n      name,\n      rscript = /<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi,\n      scriptTypeRE = /^(?:text|application)\\/javascript/i,\n      xmlTypeRE = /^(?:text|application)\\/xml/i,\n      jsonType = 'application/json',\n      htmlType = 'text/html',\n      blankRE = /^\\s*$/,\n      originAnchor = document.createElement('a')\n\n  originAnchor.href = window.location.href\n\n  // trigger a custom event and return false if it was cancelled\n  function triggerAndReturn(context, eventName, data) {\n    var event = $.Event(eventName)\n    $(context).trigger(event, data)\n    return !event.isDefaultPrevented()\n  }\n\n  // trigger an Ajax \"global\" event\n  function triggerGlobal(settings, context, eventName, data) {\n    if (settings.global) return triggerAndReturn(context || document, eventName, data)\n  }\n\n  // Number of active Ajax requests\n  $.active = 0\n\n  function ajaxStart(settings) {\n    if (settings.global && $.active++ === 0) triggerGlobal(settings, null, 'ajaxStart')\n  }\n  function ajaxStop(settings) {\n    if (settings.global && !(--$.active)) triggerGlobal(settings, null, 'ajaxStop')\n  }\n\n  // triggers an extra global event \"ajaxBeforeSend\" that's like \"ajaxSend\" but cancelable\n  function ajaxBeforeSend(xhr, settings) {\n    var context = settings.context\n    if (settings.beforeSend.call(context, xhr, settings) === false ||\n        triggerGlobal(settings, context, 'ajaxBeforeSend', [xhr, settings]) === false)\n      return false\n\n    triggerGlobal(settings, context, 'ajaxSend', [xhr, settings])\n  }\n  function ajaxSuccess(data, xhr, settings, deferred) {\n    var context = settings.context, status = 'success'\n    settings.success.call(context, data, status, xhr)\n    if (deferred) deferred.resolveWith(context, [data, status, xhr])\n    triggerGlobal(settings, context, 'ajaxSuccess', [xhr, settings, data])\n    ajaxComplete(status, xhr, settings)\n  }\n  // type: \"timeout\", \"error\", \"abort\", \"parsererror\"\n  function ajaxError(error, type, xhr, settings, deferred) {\n    var context = settings.context\n    settings.error.call(context, xhr, type, error)\n    if (deferred) deferred.rejectWith(context, [xhr, type, error])\n    triggerGlobal(settings, context, 'ajaxError', [xhr, settings, error || type])\n    ajaxComplete(type, xhr, settings)\n  }\n  // status: \"success\", \"notmodified\", \"error\", \"timeout\", \"abort\", \"parsererror\"\n  function ajaxComplete(status, xhr, settings) {\n    var context = settings.context\n    settings.complete.call(context, xhr, status)\n    triggerGlobal(settings, context, 'ajaxComplete', [xhr, settings])\n    ajaxStop(settings)\n  }\n\n  function ajaxDataFilter(data, type, settings) {\n    if (settings.dataFilter == empty) return data\n    var context = settings.context\n    return settings.dataFilter.call(context, data, type)\n  }\n\n  // Empty function, used as default callback\n  function empty() {}\n\n  $.ajaxJSONP = function(options, deferred){\n    if (!('type' in options)) return $.ajax(options)\n\n    var _callbackName = options.jsonpCallback,\n      callbackName = ($.isFunction(_callbackName) ?\n        _callbackName() : _callbackName) || ('Zepto' + (jsonpID++)),\n      script = document.createElement('script'),\n      originalCallback = window[callbackName],\n      responseData,\n      abort = function(errorType) {\n        $(script).triggerHandler('error', errorType || 'abort')\n      },\n      xhr = { abort: abort }, abortTimeout\n\n    if (deferred) deferred.promise(xhr)\n\n    $(script).on('load error', function(e, errorType){\n      clearTimeout(abortTimeout)\n      $(script).off().remove()\n\n      if (e.type == 'error' || !responseData) {\n        ajaxError(null, errorType || 'error', xhr, options, deferred)\n      } else {\n        ajaxSuccess(responseData[0], xhr, options, deferred)\n      }\n\n      window[callbackName] = originalCallback\n      if (responseData && $.isFunction(originalCallback))\n        originalCallback(responseData[0])\n\n      originalCallback = responseData = undefined\n    })\n\n    if (ajaxBeforeSend(xhr, options) === false) {\n      abort('abort')\n      return xhr\n    }\n\n    window[callbackName] = function(){\n      responseData = arguments\n    }\n\n    script.src = options.url.replace(/\\?(.+)=\\?/, '?$1=' + callbackName)\n    document.head.appendChild(script)\n\n    if (options.timeout > 0) abortTimeout = setTimeout(function(){\n      abort('timeout')\n    }, options.timeout)\n\n    return xhr\n  }\n\n  $.ajaxSettings = {\n    // Default type of request\n    type: 'GET',\n    // Callback that is executed before request\n    beforeSend: empty,\n    // Callback that is executed if the request succeeds\n    success: empty,\n    // Callback that is executed the the server drops error\n    error: empty,\n    // Callback that is executed on request complete (both: error and success)\n    complete: empty,\n    // The context for the callbacks\n    context: null,\n    // Whether to trigger \"global\" Ajax events\n    global: true,\n    // Transport\n    xhr: function () {\n      return new window.XMLHttpRequest()\n    },\n    // MIME types mapping\n    // IIS returns Javascript as \"application/x-javascript\"\n    accepts: {\n      script: 'text/javascript, application/javascript, application/x-javascript',\n      json:   jsonType,\n      xml:    'application/xml, text/xml',\n      html:   htmlType,\n      text:   'text/plain'\n    },\n    // Whether the request is to another domain\n    crossDomain: false,\n    // Default timeout\n    timeout: 0,\n    // Whether data should be serialized to string\n    processData: true,\n    // Whether the browser should be allowed to cache GET responses\n    cache: true,\n    //Used to handle the raw response data of XMLHttpRequest.\n    //This is a pre-filtering function to sanitize the response.\n    //The sanitized response should be returned\n    dataFilter: empty\n  }\n\n  function mimeToDataType(mime) {\n    if (mime) mime = mime.split(';', 2)[0]\n    return mime && ( mime == htmlType ? 'html' :\n      mime == jsonType ? 'json' :\n      scriptTypeRE.test(mime) ? 'script' :\n      xmlTypeRE.test(mime) && 'xml' ) || 'text'\n  }\n\n  function appendQuery(url, query) {\n    if (query == '') return url\n    return (url + '&' + query).replace(/[&?]{1,2}/, '?')\n  }\n\n  // serialize payload and append it to the URL for GET requests\n  function serializeData(options) {\n    if (options.processData && options.data && $.type(options.data) != \"string\")\n      options.data = $.param(options.data, options.traditional)\n    if (options.data && (!options.type || options.type.toUpperCase() == 'GET' || 'jsonp' == options.dataType))\n      options.url = appendQuery(options.url, options.data), options.data = undefined\n  }\n\n  $.ajax = function(options){\n    var settings = $.extend({}, options || {}),\n        deferred = $.Deferred && $.Deferred(),\n        urlAnchor, hashIndex\n    for (key in $.ajaxSettings) if (settings[key] === undefined) settings[key] = $.ajaxSettings[key]\n\n    ajaxStart(settings)\n\n    if (!settings.crossDomain) {\n      urlAnchor = document.createElement('a')\n      urlAnchor.href = settings.url\n      // cleans up URL for .href (IE only), see https://github.com/madrobby/zepto/pull/1049\n      urlAnchor.href = urlAnchor.href\n      settings.crossDomain = (originAnchor.protocol + '//' + originAnchor.host) !== (urlAnchor.protocol + '//' + urlAnchor.host)\n    }\n\n    if (!settings.url) settings.url = window.location.toString()\n    if ((hashIndex = settings.url.indexOf('#')) > -1) settings.url = settings.url.slice(0, hashIndex)\n    serializeData(settings)\n\n    var dataType = settings.dataType, hasPlaceholder = /\\?.+=\\?/.test(settings.url)\n    if (hasPlaceholder) dataType = 'jsonp'\n\n    if (settings.cache === false || (\n         (!options || options.cache !== true) &&\n         ('script' == dataType || 'jsonp' == dataType)\n        ))\n      settings.url = appendQuery(settings.url, '_=' + Date.now())\n\n    if ('jsonp' == dataType) {\n      if (!hasPlaceholder)\n        settings.url = appendQuery(settings.url,\n          settings.jsonp ? (settings.jsonp + '=?') : settings.jsonp === false ? '' : 'callback=?')\n      return $.ajaxJSONP(settings, deferred)\n    }\n\n    var mime = settings.accepts[dataType],\n        headers = { },\n        setHeader = function(name, value) { headers[name.toLowerCase()] = [name, value] },\n        protocol = /^([\\w-]+:)\\/\\//.test(settings.url) ? RegExp.$1 : window.location.protocol,\n        xhr = settings.xhr(),\n        nativeSetHeader = xhr.setRequestHeader,\n        abortTimeout\n\n    if (deferred) deferred.promise(xhr)\n\n    if (!settings.crossDomain) setHeader('X-Requested-With', 'XMLHttpRequest')\n    setHeader('Accept', mime || '*/*')\n    if (mime = settings.mimeType || mime) {\n      if (mime.indexOf(',') > -1) mime = mime.split(',', 2)[0]\n      xhr.overrideMimeType && xhr.overrideMimeType(mime)\n    }\n    if (settings.contentType || (settings.contentType !== false && settings.data && settings.type.toUpperCase() != 'GET'))\n      setHeader('Content-Type', settings.contentType || 'application/x-www-form-urlencoded')\n\n    if (settings.headers) for (name in settings.headers) setHeader(name, settings.headers[name])\n    xhr.setRequestHeader = setHeader\n\n    xhr.onreadystatechange = function(){\n      if (xhr.readyState == 4) {\n        xhr.onreadystatechange = empty\n        clearTimeout(abortTimeout)\n        var result, error = false\n        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304 || (xhr.status == 0 && protocol == 'file:')) {\n          dataType = dataType || mimeToDataType(settings.mimeType || xhr.getResponseHeader('content-type'))\n\n          if (xhr.responseType == 'arraybuffer' || xhr.responseType == 'blob')\n            result = xhr.response\n          else {\n            result = xhr.responseText\n\n            try {\n              // http://perfectionkills.com/global-eval-what-are-the-options/\n              // sanitize response accordingly if data filter callback provided\n              result = ajaxDataFilter(result, dataType, settings)\n              if (dataType == 'script')    (1,eval)(result)\n              else if (dataType == 'xml')  result = xhr.responseXML\n              else if (dataType == 'json') result = blankRE.test(result) ? null : $.parseJSON(result)\n            } catch (e) { error = e }\n\n            if (error) return ajaxError(error, 'parsererror', xhr, settings, deferred)\n          }\n\n          ajaxSuccess(result, xhr, settings, deferred)\n        } else {\n          ajaxError(xhr.statusText || null, xhr.status ? 'error' : 'abort', xhr, settings, deferred)\n        }\n      }\n    }\n\n    if (ajaxBeforeSend(xhr, settings) === false) {\n      xhr.abort()\n      ajaxError(null, 'abort', xhr, settings, deferred)\n      return xhr\n    }\n\n    var async = 'async' in settings ? settings.async : true\n    xhr.open(settings.type, settings.url, async, settings.username, settings.password)\n\n    if (settings.xhrFields) for (name in settings.xhrFields) xhr[name] = settings.xhrFields[name]\n\n    for (name in headers) nativeSetHeader.apply(xhr, headers[name])\n\n    if (settings.timeout > 0) abortTimeout = setTimeout(function(){\n        xhr.onreadystatechange = empty\n        xhr.abort()\n        ajaxError(null, 'timeout', xhr, settings, deferred)\n      }, settings.timeout)\n\n    // avoid sending empty string (#319)\n    xhr.send(settings.data ? settings.data : null)\n    return xhr\n  }\n\n  // handle optional data/success arguments\n  function parseArguments(url, data, success, dataType) {\n    if ($.isFunction(data)) dataType = success, success = data, data = undefined\n    if (!$.isFunction(success)) dataType = success, success = undefined\n    return {\n      url: url\n    , data: data\n    , success: success\n    , dataType: dataType\n    }\n  }\n\n  $.get = function(/* url, data, success, dataType */){\n    return $.ajax(parseArguments.apply(null, arguments))\n  }\n\n  $.post = function(/* url, data, success, dataType */){\n    var options = parseArguments.apply(null, arguments)\n    options.type = 'POST'\n    return $.ajax(options)\n  }\n\n  $.getJSON = function(/* url, data, success */){\n    var options = parseArguments.apply(null, arguments)\n    options.dataType = 'json'\n    return $.ajax(options)\n  }\n\n  $.fn.load = function(url, data, success){\n    if (!this.length) return this\n    var self = this, parts = url.split(/\\s/), selector,\n        options = parseArguments(url, data, success),\n        callback = options.success\n    if (parts.length > 1) options.url = parts[0], selector = parts[1]\n    options.success = function(response){\n      self.html(selector ?\n        $('<div>').html(response.replace(rscript, \"\")).find(selector)\n        : response)\n      callback && callback.apply(self, arguments)\n    }\n    $.ajax(options)\n    return this\n  }\n\n  var escape = encodeURIComponent\n\n  function serialize(params, obj, traditional, scope){\n    var type, array = $.isArray(obj), hash = $.isPlainObject(obj)\n    $.each(obj, function(key, value) {\n      type = $.type(value)\n      if (scope) key = traditional ? scope :\n        scope + '[' + (hash || type == 'object' || type == 'array' ? key : '') + ']'\n      // handle data in serializeArray() format\n      if (!scope && array) params.add(value.name, value.value)\n      // recurse into nested objects\n      else if (type == \"array\" || (!traditional && type == \"object\"))\n        serialize(params, value, traditional, key)\n      else params.add(key, value)\n    })\n  }\n\n  $.param = function(obj, traditional){\n    var params = []\n    params.add = function(key, value) {\n      if ($.isFunction(value)) value = value()\n      if (value == null) value = \"\"\n      this.push(escape(key) + '=' + escape(value))\n    }\n    serialize(params, obj, traditional)\n    return params.join('&').replace(/%20/g, '+')\n  }\n})(Zepto)\n\n;(function($){\n  $.fn.serializeArray = function() {\n    var name, type, result = [],\n      add = function(value) {\n        if (value.forEach) return value.forEach(add)\n        result.push({ name: name, value: value })\n      }\n    if (this[0]) $.each(this[0].elements, function(_, field){\n      type = field.type, name = field.name\n      if (name && field.nodeName.toLowerCase() != 'fieldset' &&\n        !field.disabled && type != 'submit' && type != 'reset' && type != 'button' && type != 'file' &&\n        ((type != 'radio' && type != 'checkbox') || field.checked))\n          add($(field).val())\n    })\n    return result\n  }\n\n  $.fn.serialize = function(){\n    var result = []\n    this.serializeArray().forEach(function(elm){\n      result.push(encodeURIComponent(elm.name) + '=' + encodeURIComponent(elm.value))\n    })\n    return result.join('&')\n  }\n\n  $.fn.submit = function(callback) {\n    if (0 in arguments) this.bind('submit', callback)\n    else if (this.length) {\n      var event = $.Event('submit')\n      this.eq(0).trigger(event)\n      if (!event.isDefaultPrevented()) this.get(0).submit()\n    }\n    return this\n  }\n\n})(Zepto)\n\n;(function(){\n  // getComputedStyle shouldn't freak out when called\n  // without a valid element as argument\n  try {\n    getComputedStyle(undefined)\n  } catch(e) {\n    var nativeGetComputedStyle = getComputedStyle\n    window.getComputedStyle = function(element, pseudoElement){\n      try {\n        return nativeGetComputedStyle(element, pseudoElement)\n      } catch(e) {\n        return null\n      }\n    }\n  }\n})()\n  return Zepto\n}))\n\n\n//# sourceURL=webpack:///./node_modules/zepto-webpack/zepto.js?");

/***/ }),

/***/ "./src/Knife.js":
/*!**********************!*\
  !*** ./src/Knife.js ***!
  \**********************/
/*! exports provided: Knife */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Knife\", function() { return Knife; });\n var objId = 0;\r\n class Knife{\r\n    constructor(config,objID,MAINBACK){\r\n        this.isCanMove = false;\r\n        config.id = objID;\r\n        this.id = objID;//刀子的id\r\n        \r\n        this.MAINBACK = MAINBACK;//插进水果之后的回调\r\n        this.objctknifeInfo = null;//当前zetop的游戏体\r\n        \r\n        \r\n\r\n        this.config = config;\r\n        this.init(this.id,config);\r\n    }\r\n    init(id,config){\r\n        //创造出来一个刀子\r\n        var objctknifeF = `<div class=\"gs-launch\" id=knife-${id}></div>`\r\n        //取到id\r\n        this.objID = `#knife-${id}`; \r\n        //创建node\r\n        $(`#${config.bornAreaID}`).append(objctknifeF);\r\n        //取到此节点\r\n        this.objctknife = $(`#${config.bornAreaID}`).children(this.objID)[0];  \r\n        this.topNum = 1000 /40;\r\n        this.objctknifeInfo = $(this.objID); \r\n         \r\n    }\r\n    move(BACK=null){ \r\n        if(this.isCanMove === false) return;\r\n        this.topNum -= 2.5; \r\n        // this.objctknife.style.top = `${this.topNum}px`\r\n        this.objctknife.style.top = `${this.topNum}rem`\r\n        // console.log('this.objctknife.style.top:',this.objctknife.style.top);\r\n        if(this.topNum<= 18){//检测到了制定的坐标就变为大转盘的子节点\r\n            this.isCanMove = false\r\n            this.setRotation(this.config,this.objctknife); \r\n            //插入了大转盘 执行一个回调\r\n            if(BACK!=null){\r\n                BACK(); \r\n            }\r\n        } \r\n    }\r\n    //变为大转盘的子节点\r\n    toBeTurntableChild(config,selfNode){\r\n        this.objctknife.style.top = `${config.x}rem`;//设置刀子的坐标 \r\n        this.objctknife.style.left = `${config.y}rem`;//设置刀子的坐标  \r\n        this.objctknife.style.transform  = `rotate(${-config.rotate}deg)`;\r\n\r\n        $(`#${config.parentID}`).append(selfNode);\r\n        //刀子发射的回调\r\n        this.mainBackFun();\r\n        \r\n    }\r\n    //计算出角度与坐标\r\n    setRotation(config,selfNode){   \r\n        let docEl = document.documentElement.style.fontSize;  \r\n        let R_ = config.node.rotate.num  ;\r\n        R_  = R_ - Math.floor(R_ / 360) * 360;\r\n        let x_ = (config.node.width*config.radiusRatio *Math.cos((R_ )/180*Math.PI) + config.node.width*(0.08))*window.remscale; \r\n        let y_ = (config.node.height*config.radiusRatio *Math.sin((R_ )/180*Math.PI) + config.node.height*(0.2))*window.remscale;  \r\n        config.rotate = R_; \r\n        config.x = (x_/window.realfz).toFixed(2);\r\n        config.y =( y_/window.realfz).toFixed(2); \r\n        this.toBeTurntableChild(config, selfNode); \r\n    } \r\n    //回调方法\r\n    mainBackFun(){\r\n        if(this.MAINBACK!=null || this.MAINBACK!=undefined || this.MAINBACK!=''){\r\n            this.MAINBACK();\r\n        }\r\n    }\r\n    //移除自己\r\n    isRemove(){\r\n        $(this.objID).remove();\r\n    }\r\n    //取到玩家碰撞的信息\r\n    getCollideInfo(){\r\n        return {\r\n            x:this.objctknifeInfo.offset().left-30,\r\n            y:this.objctknifeInfo.offset().top,\r\n            width:30,\r\n            height:95\r\n        } \r\n    }\r\n \r\n}        \r\n \n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! zepto-webpack */ \"./node_modules/zepto-webpack/zepto.js\")))\n\n//# sourceURL=webpack:///./src/Knife.js?");

/***/ }),

/***/ "./src/TurntableAni.js":
/*!*****************************!*\
  !*** ./src/TurntableAni.js ***!
  \*****************************/
/*! exports provided: TurntableAni */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TurntableAni\", function() { return TurntableAni; });\nclass TurntableAni{\r\n    /**\r\n     * 轮子被碰撞的动画\r\n     */\r\n    constructor(positionX,positionY,nodeID){\r\n        //停止动画\r\n        this.stopAni = true;\r\n        //移动的坐标数组\r\n        this.movelist = null,\r\n        //当前的游戏体\r\n        //node\r\n        this.qjNode =  $(`#${nodeID}`);\r\n        //node\r\n        this.gameNode = this.qjNode[0];\r\n        //初始化的坐标\r\n        this.positionX = positionX;\r\n        this.positionY = positionY; \r\n        //生成多少帧的动画坐标0\r\n        this.speedNum = 1000/10;\r\n        //第几帧动画的只\r\n        this.indexNum =0;   \r\n        //结束的回调状态\r\n        this.isBackStatus = false;\r\n        //回调函数 动画结束的\r\n        this.overBackFun = null;\r\n    }\r\n      /**\r\n         * 设置左边飞行的动画路径\r\n         */\r\n        setLeftMove(){\r\n            this.indexNum =0; \r\n            this.movelist = this.bser( [{ x: this.positionX, y: this.positionY},{ x:74, y: 7},{ x: 23, y: 126},{ x: 22, y: 1200}] ,this.speedNum);\r\n            // this.stopAni = false \r\n            // console.log('当前的内容:',this.movelist)\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * 设置右边动画飞行的路径\r\n         */\r\n        setRightMove(){\r\n            this.indexNum =0; \r\n            this.movelist = this.bser( [{ x: this.positionX, y: this.positionY},{ x: 2*this.positionX-74, y: 7},{ x: 2*this.positionX-23, y: 126},{ x: 2*this.positionX-22, y: 1200}] ,this.speedNum);\r\n            // this.stopAni = false\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * 动画的执行\r\n         */\r\n        Animation(){\r\n       \r\n            // 是否能开始动画\r\n            if(this.stopAni &&this.gameNode && this.movelist.length>0){\r\n                return;\r\n            }\r\n            //是不是用完了动画帧\r\n            if(this.speedNum -1 < this.indexNum ){\r\n                //控制每次结束仅仅回调一次\r\n                if(this.isBackStatus){\r\n                    this.isBackStatus = false;\r\n                    //动画结束方法启用回调\r\n                    if(this.overBackFun){\r\n                        this.overBackFun();\r\n                    }  \r\n                }\r\n                return;\r\n            }\r\n            //当前的动画\r\n            this.indexNum++;\r\n        \r\n            if(this.movelist[this.indexNum]){ \r\n                this.position(this.movelist[this.indexNum].e,this.movelist[this.indexNum].f);\r\n            } \r\n        } \r\n        /**\r\n         * 设置当前的node坐标位置的位置\r\n         * @param {number} x \r\n         * @param {number} y \r\n         */\r\n        position(x,y){\r\n            let _x = (x/window.realfz).toFixed(2);\r\n            let _y = (y/window.realfz).toFixed(2); \r\n            this.gameNode.style.top = `${_y}rem`;//设置刀子的坐标 \r\n            this.gameNode.style.left = `${_x}rem`;//设置刀子的坐标   \r\n       }\r\n       /**\r\n        * 开始动画\r\n        */\r\n       beginAni(){\r\n           //从零帧开始\r\n            this.indexNum = 0;\r\n           //打开活动\r\n            this.stopAni = false;\r\n            //初始化位置\r\n            this.position(this.positionX,this.positionY);\r\n            this.isBackStatus = true;\r\n            return this;\r\n       }\r\n       /**\r\n        * 动画结束后的回调\r\n        * @param {function} BACK \r\n        */\r\n       AnimationOver(BACK=null){\r\n           if(BACK!=null){\r\n            this.overBackFun = BACK;\r\n           }  \r\n       }\r\n       /**\r\n        * 设置的分开柠檬是显示开始显示\r\n        * @param {boolean} bool \r\n        */\r\n       setActive(bool = false){ \r\n            let node = $('#pass-over-ani');\r\n            if(bool){\r\n                node.show();\r\n            }else{\r\n                node.hide();\r\n            } \r\n       }\r\n        /**\r\n         * 赛贝尔函数使用用户\r\n         * @param{any}anchorpoints 传入的{起始点的x,y}，{起始点的参数x,y},{末位点的参数x,y},{末位点的采纳数x,y}\r\n         * @param{number}pointsAmount 速度参数\r\n         * @returns {e,f} 返回的 {x，y}的参数在坐标的体系中\r\n         */\r\n        bser(anchorpoints, pointsAmount) {\r\n            let points = [];\r\n            for (let i = 0; i < pointsAmount; i++) {\r\n                let point = MultiPointBezier(anchorpoints, i / pointsAmount);\r\n                points.push(point);\r\n            }\r\n            return points;\r\n            function MultiPointBezier(points_, t) {//t贞数\r\n                let len = points_.length;\r\n                let x = 0, y = 0;\r\n                let erxiangshi = function (start, end) {\r\n                    let cs = 1, bcs = 1;\r\n                    while (end > 0) {\r\n                        cs *= start;\r\n                        bcs *= end;\r\n                        start--;\r\n                        end--;\r\n                    }\r\n                    return (cs / bcs);\r\n                };\r\n                for (let i = 0; i < len; i++) {\r\n                    let point = points_[i];\r\n                    x +=/*Math.round()*/ point.x * Math.pow((1 - t), (len - 1 - i)) * Math.pow(t, i) * (erxiangshi(len - 1, i));//x弧度\r\n                    y +=/*Math.round()*/ point.y * Math.pow((1 - t), (len - 1 - i)) * Math.pow(t, i) * (erxiangshi(len - 1, i));//y弧度\r\n                }\r\n                return { e: x, f: y };\r\n            }\r\n        } \r\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! zepto-webpack */ \"./node_modules/zepto-webpack/zepto.js\")))\n\n//# sourceURL=webpack:///./src/TurntableAni.js?");

/***/ }),

/***/ "./src/assets/tool/Zepto.fx.js":
/*!*************************************!*\
  !*** ./src/assets/tool/Zepto.fx.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\r\n/**\r\n * Zepto.fx.js\r\n *\r\n * 这个功能是Zepto封装的插件animate动画包\r\n *  1、 根据浏览器属性获取前缀，并设置cssReset的属性名称前加入前缀，\r\n *  2、$.fn.animate 的主要功能其实是判断并修正参数，最后调用的$.fn.anim才是操作动画的核心方法。\r\n * (c) 2010-2015 Thomas Fuchs\r\n * Zepto.js may be freely distributed under the MIT license.\r\n * @param {Object} $\r\n * @param {Object} undefined\r\n */\r\n;(function($, undefined) {\r\n    var prefix = '',\r\n        eventPrefix, // prefix浏览器前缀 -webkit等，eventPrefix事件前缀\r\n        vendors = {\r\n            Webkit: 'webkit',\r\n            Moz: '',\r\n            O: 'o'\r\n        }, //前缀数据源 不包含IE\r\n        testEl = document.createElement('div'), //临时DIV容器\r\n        supportedTransforms = /^((translate|rotate|scale)(X|Y|Z|3d)?|matrix(3d)?|perspective|skew(X|Y)?)$/i, //变形检测\r\n        transform, //变形\r\n        transitionProperty, transitionDuration, transitionTiming, transitionDelay, //过渡\r\n        animationName, animationDuration, animationTiming, animationDelay, //动画\r\n        cssReset = {}\r\n\r\n    //将驼峰字符串转成css属性，如aB-->a-b\r\n    function dasherize(str) {\r\n        return str.replace(/([a-z])([A-Z])/, '$1-$2').toLowerCase()\r\n    }\r\n\r\n    //修正事件名\r\n    function normalizeEvent(name) {\r\n        return eventPrefix ? eventPrefix + name : name.toLowerCase()\r\n    }\r\n\r\n    /**\r\n     * 根据浏览器内核，设置CSS前缀，事件前缀\r\n     * 如-webkit， css：-webkit-  event:webkit\r\n     * 这里会在vendors存储webkit，moz，o三种前缀\r\n     */\r\n    $.each(vendors, function(vendor, event) {\r\n        if(testEl.style[vendor + 'TransitionProperty'] !== undefined) {\r\n            prefix = '-' + vendor.toLowerCase() + '-'\r\n            eventPrefix = event\r\n            return false\r\n        }\r\n    })\r\n\r\n    transform = prefix + 'transform' //变形\r\n\r\n    //过渡,对于css属性重新设置前缀\r\n    cssReset[transitionProperty = prefix + 'transition-property'] =\r\n        cssReset[transitionDuration = prefix + 'transition-duration'] =\r\n            cssReset[transitionDelay = prefix + 'transition-delay'] =\r\n                cssReset[transitionTiming = prefix + 'transition-timing-function'] =\r\n                    cssReset[animationName = prefix + 'animation-name'] =\r\n                        cssReset[animationDuration = prefix + 'animation-duration'] =\r\n                            cssReset[animationDelay = prefix + 'animation-delay'] =\r\n                                cssReset[animationTiming = prefix + 'animation-timing-function'] = ''\r\n\r\n    /**\r\n     * 动画常量数据源，默认设置\r\n     * @type {{off: boolean, speeds: {_default: number, fast: number, slow: number}, cssPrefix: string, transitionEnd: *, animationEnd: *}}\r\n     */\r\n    $.fx = {\r\n        off: (eventPrefix === undefined && testEl.style.transitionProperty === undefined), //能力检测是否支持动画，具体检测是否支持过渡，支持过渡事件\r\n        speeds: {\r\n            _default: 400,\r\n            fast: 200,\r\n            slow: 600\r\n        },\r\n        cssPrefix: prefix, //css 前缀  如-webkit-\r\n        transitionEnd: normalizeEvent('TransitionEnd'), //过渡结束事件\r\n        animationEnd: normalizeEvent('AnimationEnd') //动画播放结束事件\r\n    }\r\n\r\n    /**\r\n     * 创建自定义动画\r\n     * @param properties  样式集\r\n     * @param duration 持续事件\r\n     * @param ease    速率\r\n     * @param callback  完成时的回调\r\n     * @param delay     动画延迟\r\n     * @returns {*}\r\n     */\r\n    // 这里是对参数的修正和处理，真正操作的是anim方法\r\n    $.fn.animate = function(properties, duration, ease, callback, delay) {\r\n        //参数修正，传参为function(properties,callback)\r\n        if($.isFunction(duration))\r\n            callback = duration, ease = undefined, duration = undefined\r\n        if($.isFunction(ease)) //传参为function(properties,duration，callback)\r\n            callback = ease, ease = undefined\r\n        if($.isPlainObject(duration)) //传参为function(properties,｛｝)\r\n            ease = duration.easing, callback = duration.complete, delay = duration.delay, duration = duration.duration\r\n        // duration 数字：持续时间  字符串：取speeds: { _default: 400, fast: 200, slow: 600 }对应数字\r\n        if(duration) duration = (typeof duration == 'number' ? duration :\r\n            ($.fx.speeds[duration] || $.fx.speeds._default)) / 1000 //动画持续时间默认值\r\n        if(delay) delay = parseFloat(delay) / 1000 //延迟时间，除以1000转换成s\r\n        return this.anim(properties, duration, ease, callback, delay)\r\n    }\r\n\r\n    /**\r\n     * 动画核心方法\r\n     * @param properties  样式集\r\n     * @param duration 持续事件\r\n     * @param ease    速率\r\n     * @param callback  完成时的回调\r\n     * @param delay     动画延迟\r\n     * @returns {*}\r\n     */\r\n    $.fn.anim = function(properties, duration, ease, callback, delay) {\r\n        var key, cssValues = {},\r\n            cssProperties, transforms = '', // transforms 变形   cssValues设置给DOM的样式\r\n            that = this,\r\n            wrappedCallback, endEvent = $.fx.transitionEnd,\r\n            fired = false\r\n\r\n        //修正持续时间\r\n        if(duration === undefined) duration = $.fx.speeds._default / 1000\r\n        if(delay === undefined) delay = 0\r\n\r\n        //如果浏览器不支持动画，持续时间设为0，直接跳动画结束\r\n        if($.fx.off) duration = 0\r\n\r\n        // properties是动画名\r\n        if(typeof properties == 'string') {\r\n            // keyframe [animationName] = properties\r\n            cssValues[animationName] = properties\r\n            cssValues[animationDuration] = duration + 's'\r\n            cssValues[animationDelay] = delay + 's'\r\n            cssValues[animationTiming] = (ease || 'linear')\r\n            endEvent = $.fx.animationEnd //动画结束事件\r\n        } else { //properties 是样式集\r\n            cssProperties = []\r\n            // CSS transitionsanimation\r\n            cssValues\r\n            for(key in properties)\r\n                // supportedTransforms.test(key) 正则检测是否为变形\r\n                // key + '(' + properties[key] + ') '拼凑成变形方法\r\n                if(supportedTransforms.test(key)) transforms += key + '(' + properties[key] + ') '\r\n                else cssValues[key] = properties[key], cssProperties.push(dasherize(key))\r\n            // console.log(transforms)\r\n\r\n            // 变形统一存入  cssValues   cssProperties\r\n            if(transforms) cssValues[transform] = transforms, cssProperties.push(transform)\r\n\r\n            // duration > 0可以播放动画，且properties是对象，表明为过渡，上面有字符串，则为animate\r\n            if(duration > 0 && typeof properties === 'object') {\r\n                cssValues[transitionProperty] = cssProperties.join(', ')\r\n                cssValues[transitionDuration] = duration + 's'\r\n                cssValues[transitionDelay] = delay + 's'\r\n                cssValues[transitionTiming] = (ease || 'linear') //默认线性速率\r\n            }\r\n        }\r\n\r\n        //动画完成后的响应函数\r\n        wrappedCallback = function(event) {\r\n            if(typeof event !== 'undefined') {\r\n                if(event.target !== event.currentTarget) return // makes sure the event didn't bubble from \"below\"\r\n                $(event.target).unbind(endEvent, wrappedCallback)\r\n            } else\r\n                $(this).unbind(endEvent, wrappedCallback) // triggered by setTimeout\r\n\r\n            fired = true\r\n            // TODO 既然已经执行完了，为什么这里要重复css一下，不太理解\r\n            $(this).css(cssReset)\r\n            callback && callback.call(this)\r\n        }\r\n\r\n        //处理动画结束事件\r\n        if(duration > 0) {\r\n            //绑定动画结束事件\r\n            this.bind(endEvent, wrappedCallback)\r\n            // transitionEnd is not always firing on older Android phones\r\n            // so make sure it gets fired\r\n\r\n            //延时ms后执行动画，注意这里加了25ms，保持endEvent，动画先执行完。\r\n            //绑定过事件还做延时处理，是transitionEnd在older Android phones不一定触发\r\n            setTimeout(function() {\r\n                //如果触发过，就不处理\r\n                if(fired) return\r\n                wrappedCallback.call(that)\r\n            }, ((duration + delay) * 1000) + 25)\r\n        }\r\n\r\n        // trigger page reflow so new elements can animate\r\n        //主动触发页面回流，刷新DOM，让接下来设置的动画可以正确播放\r\n        //更改 offsetTop、offsetLeft、 offsetWidth、offsetHeight；scrollTop、scrollLeft、scrollWidth、scrollHeight；clientTop、clientLeft、clientWidth、clientHeight；getComputedStyle() 、currentStyle（）。这些都会触发回流。回流导致DOM重新渲染，平时要尽可能避免，但这里，为了动画即时生效播放，则主动触发回流，刷新DOM。\r\n        // 与.length属性一致\r\n        this.size() && this.get(0).clientLeft\r\n\r\n        //设置样式，启动动画\r\n        this.css(cssValues)\r\n\r\n        // duration为0，即浏览器不支持动画的情况，直接执行动画结束，执行回调。\r\n        if(duration <= 0) setTimeout(function() {\r\n            that.each(function() {\r\n                wrappedCallback.call(this)\r\n            })\r\n        }, 0)\r\n\r\n        return this;\r\n    }\r\n\r\n    testEl = null //去掉不必要的数据存储，便于垃圾回收\r\n})(Zepto)\r\n\n\n//# sourceURL=webpack:///./src/assets/tool/Zepto.fx.js?");

/***/ }),

/***/ "./src/config/point.js":
/*!*****************************!*\
  !*** ./src/config/point.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function($) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return countinfoPoint; });\n//埋点 \r\nclass countinfoPoint {\r\n    /**\r\n     * 传入是测试服 还是正式服的发送的埋点的链接\r\n     * @param _urlPoint 传入当前是不是正式服\r\n     */\r\n    constructor(_urlPoint) {\r\n        this.urlPoint = _urlPoint == true ? 'https://adscount.fawulu.com/award/countInf0' : 'http://47.98.242.33:15018/award/countInf0';//链接地址;\r\n    }\r\n\r\n    /**\r\n     * 发送相关的埋点  3首页，4参与\r\n     * @param activeTyoe\r\n     */\r\n    setPonitType(activeTyoe) {\r\n        this.countinfoPoint(activeTyoe);\r\n        this.senIamgInfoPoint(activeTyoe === 3 ? 3001 : 4001)\r\n    }\r\n    /**\r\n     * 发送相关的埋点  3 或者是 4\r\n     * @param activeTyoe 3首页，4参与\r\n     */\r\n    countinfoPoint(activeTyoe) {\r\n        var obj = {\r\n            appkey: this.appkey || this.GetRequestKey('appkey'),\r\n            uid: this.uid || this.GetRequestKey('uid'),\r\n            business: this.business || this.GetRequestKey('business'),\r\n            activityid: this.activityid || this.GetRequestKey('activityid'),\r\n            ua: this.getEv(),\r\n            appos: this.isIOS(),\r\n            modeltype: activeTyoe,//3首页，4参与\r\n            modelname: activeTyoe === 3 ? '首页' : '参与',//3首页，4参与\r\n            random3: this.getWH(),//屏幕宽,屏幕高\r\n\r\n        }\r\n        var formData = new FormData();\r\n        formData.append(\"appkey\", obj.appkey);\r\n        formData.append(\"uid\", obj.uid);\r\n        formData.append(\"business\", obj.business);\r\n        formData.append(\"activityid\", obj.activityid);\r\n        formData.append(\"ua\", obj.ua);\r\n        formData.append(\"appos\", obj.appos);\r\n        formData.append(\"modeltype\", obj.modeltype);\r\n        formData.append(\"modelname\", obj.modelname);\r\n        formData.append(\"random3\", obj.random3);\r\n\r\n        var request = new XMLHttpRequest();\r\n        request.open(\"POST\", this.urlPoint);\r\n        request.send(formData);\r\n\r\n\r\n    }\r\n\r\n    /**\r\n     * 图片发送的相关埋点\r\n     * @param activeTyoe （首页：3001  参与： 4001）\r\n     */\r\n    senIamgInfoPoint(activeTyoe) {\r\n        var params = {\r\n            t: Math.random(),\r\n            p: 'ads', //（写死ads）\r\n            locaurl: encodeURIComponent(location.href),\r\n            referrer: encodeURIComponent(document.referrer) || '',\r\n            sh: window.screen.height,//(屏幕高)\r\n            sw: window.screen.width,//(屏幕宽)\r\n            cd: window.screen.colorDepth || 0,\r\n            lang: navigator.language || '',\r\n            activityid: this.activityid || this.GetRequestKey('activityid'),\r\n            mt: activeTyoe,//（首页：3001  参与： 4001）\r\n            startTime: new Date().getTime(),\r\n            jsV: 20191018\r\n        }\r\n        console.log('当前图片发送的相关的参数：', params);\r\n\r\n        const img = new Image(1, 1);\r\n        const path = 'https://log.cudaojia.com:10090/dot/s.gif';\r\n        let paramsStr = '';\r\n        for (const key in params) {\r\n            paramsStr += `${paramsStr.indexOf('?') >= 0 ? '&' : '?'}${key}=${encodeURI(params[key])}`;\r\n        }\r\n        img.src = `${path}${paramsStr}`;\r\n    }\r\n\r\n\r\n    /**\r\n     * 发送链接\r\n     * @param url\r\n     * @param type\r\n     * @param obj\r\n     * @param BACK\r\n     * @param ERROR\r\n     */\r\n    setHttpCountinfo(url, type, obj = null, BACK, ERROR) {\r\n        var _openID = this.openID || this.GetRequestKey('openid');//设置openID\r\n        $.ajax({\r\n            url: url,\r\n            type: type,\r\n            data: JSON.stringify(obj),\r\n            dataType: 'json',\r\n            crossDomain: true, //强制使用5+跨域\r\n            contentType: 'application/x-www-form-urlencoded',\r\n            success: function (res) {\r\n                console.log('res:', res);\r\n                if (BACK != null) {\r\n                    BACK(res);\r\n                }\r\n            },\r\n            error: function (xhr, text) {\r\n\r\n                if (xhr.status == 200) {\r\n                    if (BACK != null) {\r\n                        BACK(text);\r\n                    }\r\n                } else {\r\n                    // console.log('text:',text,'xhr:',xhr);\r\n                    if (ERROR != null) {\r\n                        ERROR(text, xhr);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    //取到链接上的参数\r\n    GetRequestKey(key) {\r\n\r\n        var theRequest = new Object();\r\n        var url = location.href;\r\n        if (url.indexOf(\"?\") != -1) {\r\n            var str = url.split('?')[1];\r\n            str = str.split('#')[0];\r\n            var strs = str.split(\"&\");\r\n            for (var i = 0; i < strs.length; i++) {\r\n                theRequest[strs[i].split(\"=\")[0]] = unescape(strs[i].split(\"=\")[1]);\r\n\r\n            }\r\n        }\r\n        // console.log('-----取到了相关的参数:----', theRequest);\r\n        var value = theRequest[key];\r\n        this.appkey = theRequest['appkey'];\r\n        this.uid = theRequest['uid'];\r\n        this.business = theRequest['business'];\r\n        this.activityid = theRequest['activityid'];\r\n\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * 检测当前是不是微信 支付宝 或其他环境 1->微信，2->支付宝, 0->其他\r\n     * @returns {*}\r\n     */\r\n    getEv() {\r\n        //防止重复检测 浪费性能\r\n        if (this.getEvType != null && this.getEvType != undefined && this.getEvType != '') {\r\n            return this.getEvType;\r\n        }\r\n        var typeNum = 0;\r\n        var browser = navigator.userAgent.toLowerCase();\r\n        if (browser.match(/Alipay/i) == \"alipay\") {\r\n            console.log(\"支付宝app的浏览器\");\r\n            typeNum = 2;\r\n\r\n        } else if (browser.match(/MicroMessenger/i) == \"micromessenger\") {\r\n            console.log(\"微信app的浏览器\");\r\n            typeNum = 1;\r\n\r\n        }\r\n        this.getEvType = typeNum;\r\n        return typeNum;\r\n    }\r\n\r\n    /**\r\n     * 检测当前是不是ios 1->非ios，2->ios\r\n     * @returns {number|*}\r\n     */\r\n    isIOS() {\r\n        //防止重复检测 浪费性能\r\n        if (this.isIos != '' && this.isIos != null && this.isIos != undefined) {\r\n            return this.isIos;\r\n        }\r\n        var u = navigator.userAgent;\r\n        var isiOS = !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端\r\n        this.isIos = isiOS === true ? 2 : 1\r\n        return this.isIos;\r\n    }\r\n\r\n    /**\r\n     * 获取当前的宽高\r\n     * @returns {string}\r\n     */\r\n    getWH() {\r\n        if (this.isWH === '' || this.isWH === null || this.isWH === undefined) {\r\n            this.isWH = `${window.screen.width},${window.screen.height}`\r\n        }\r\n\r\n        return this.isWH;\r\n\r\n    }\r\n\r\n}\r\n\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! zepto-webpack */ \"./node_modules/zepto-webpack/zepto.js\")))\n\n//# sourceURL=webpack:///./src/config/point.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/zepto-webpack/zepto.js */ \"./node_modules/zepto-webpack/zepto.js\");\n/* harmony import */ var _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _assets_tool_Zepto_fx_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assets/tool/Zepto.fx.js */ \"./src/assets/tool/Zepto.fx.js\");\n/* harmony import */ var _assets_tool_Zepto_fx_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_assets_tool_Zepto_fx_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _Knife_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Knife.js */ \"./src/Knife.js\");\n/* harmony import */ var _TurntableAni_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TurntableAni.js */ \"./src/TurntableAni.js\");\n/* harmony import */ var _config_point_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./config/point.js */ \"./src/config/point.js\");\n__webpack_require__(/*! ./index.scss */ \"./src/index.scss\"); \r\n\r\n \r\n \r\n\r\n //埋点的处理\r\nconst gameInfo ={\r\n    phoneHand:[134,135,136,137,138,139,147,150,151,152,157,158,159,182,187,188,130,131,132,155,156,185,186],//随机出现的手机号头 \r\n    redMoney:['5元红包','100元红包','华为5G手机','ipadAir3','airPods'],//红包的金额文案数值\r\n    giveStrengthNum:2,//每天开局赠送的体力数量\r\n    whatchVideoTopNum:8,//上线的次数\r\n    playCostStrengthNum:2,//每次花费的体力数两\r\n    addStrengthNum:2,//当前看视频增加的体力数量\r\n    key:'uid',//玩家当前的本地储存的key值\r\n    btin_1:null,//看视频获得更多体力 最上面的那个\r\n    btin_2:null,//免费玩游戏的按钮\r\n    btin_3:null,//下面就是相应的奖品按钮\r\n    btin_4:null,\r\n    btin_5:null,\r\n    btin_6:null,\r\n    btin_7:null,  \r\n    passNum:0,//当前是第几关了 \r\n    waring_1:'您已超过最近大关卡数',\r\n    waring_2:'转盘已减速15%',\r\n    waring_3:'已获得2个体力',\r\n    delayNum:50,//单位是毫秒\r\n    prefabKinfeDelayNum:300,//单位是毫秒 预制刀子中的碰撞检测延时时间\r\n    successPupopDelayNum:1000,//闯关成功 最后获奖了 显示弹窗的延迟倒计时 （要留给通关钱转盘的动画时间）\r\n    failPupopDelayNum:200,//通关失败中的延迟出现通关的弹窗时间\r\n    passPupopDelayNum:1000,//正常通关中的延迟出现通关的弹窗时间（要留给通关钱转盘的动画时间）\r\n    // standBtnTopNum:2,//挽留弹窗一天出现次数的上线\r\n  \r\n}\r\n//减速道具的相关信息 \r\nlet slowDownPropInfo={\r\n    useStatus: 1,//当前道具是否可用 0正在使用中 1是可用 2不可以使用\r\n    normalSpeed:1,//正常的速度是1\r\n    speedScope:[0.8,1.8],//这个是速度的范围\r\n    speedDowm:0.85,//减去的速率\r\n    timeNumList:[[8000,10000],[3000,5000],[1500,3000],[500,1000]],//每一关的更改转盘的相关时间参数\r\n     \r\n}\r\n//游戏中的奖品信息\r\nlet rewardList={ \r\n    testPlayType :1,// 1=试玩 2奖品通关  testPlayType与rewardtPlayType是下面奖品类型中typeOfPlay都是同一个意思\r\n    rewardtPlayType:2,//2奖品通关\r\n    //下面的奖品reward1-reward7 分别从下倒下对应着几个奖品页面中的7哥选择按钮\r\n        reward1:{\r\n            id:1,\r\n            content:'获取更多体力',//这个是不需要的 因为这个是获取更多体力的 \r\n            maxPassNum:0,//关数的上线 \r\n            passKnifeNumList:[4,6,7,8],//每一关卡的刀子数量\r\n            timeNumList:[20,15,15,15],//倒计时的值\r\n            typeOfPlay :1,// 1=试玩 2奖品通关  \r\n        },\r\n        reward2:{\r\n            id:2,\r\n            content:'免费试玩',\r\n            maxPassNum:2,//关卡的上线\r\n            passKnifeNumList:[4,6,7,8],//每一关卡的刀子数量\r\n            timeNumList:[20,15,15,15],//倒计时的值\r\n            typeOfPlay :1,// 1=试玩 2奖品通关\r\n        },\r\n        reward3:{\r\n            id:3,\r\n            content:'华为5G手机', \r\n            maxPassNum:4,//关卡的上线 \r\n            passKnifeNumList:[6,9,11,16], //每一关卡的刀子数量\r\n            timeNumList:[20,15,15,15],//倒计时的值\r\n            typeOfPlay :2,// 1=试玩 2奖品通关\r\n        },\r\n        reward4:{\r\n            id:4,\r\n            content:'100元红包', \r\n            maxPassNum:4,//关卡的上线\r\n            passKnifeNumList:[6,9,11,16], //每一关卡的刀子数量 \r\n            timeNumList:[20,15,15,15],//倒计时的值\r\n            typeOfPlay :2,// 1=试玩 2奖品通关\r\n        },\r\n        reward5:{\r\n            id:5,\r\n            content:'5元红包',\r\n            maxPassNum:4,//关卡的上线 \r\n            passKnifeNumList:[6,9,11,16], //每一关卡的刀子数量\r\n            timeNumList:[20,15,15,15],//倒计时的值\r\n            typeOfPlay :2,// 1=试玩 2奖品通关\r\n        },\r\n        reward6:{\r\n            id:6,\r\n            content:'ipadAir3',\r\n            maxPassNum:4,//关卡的上线 \r\n            passKnifeNumList:[6,9,11,16], //每一关卡的刀子数量\r\n            timeNumList:[20,15,15,15],//倒计时的值\r\n            typeOfPlay :2,// 1=试玩 2奖品通关\r\n        },\r\n        reward7:{\r\n            id:7,\r\n            content:'AirPods',\r\n            maxPassNum:4,//关卡的上线\r\n            passKnifeNumList:[6,9,11,16], //每一关卡的刀子数量\r\n            timeNumList:[20,15,15,15],//倒计时的值\r\n            typeOfPlay :2,// 1=试玩 2奖品通关\r\n        }\r\n}\r\n//游戏场景中的UI\r\nlet gameSceneUI={\r\n    starts_1:null,//是星星的那个节点\r\n    starts_2:null,//是星星的那个节点\r\n    starts_3:null,//是星星的那个节点\r\n    starts_4:null,//是星星的那个节点\r\n    rewardTitle:null,//当前的奖励标题\r\n}\r\n//本地需要储存的数据\r\nlet localStorage = {\r\n    lastTime:0,//每次登入时间就会更新\r\n    strengthNum:10,//当前有多少体力 \r\n    canfreePlay:1,//0=false  1=true\r\n    whatchVideoNum:0,//当前观看过几次视频了 \r\n    standBtnTopNum:2,//后面是挽留的次数 一天可以挽留几次 没挽留一次，就将次数减去一次 0的时候说明没有挽留次数\r\n    passNum:1,//当前再第几关卡\r\n}\r\n//视频回调的类型\r\nlet watchVideosType={\r\n    changeType:1,\r\n    getStrengthNum:1,//获取体力 \r\n    playerGame:2,//没有体力在主页点击直接玩游戏\r\n    continueGame:3,//继续玩游戏复活\r\n    shiftDown:4,///减速道具\r\n    standPlayer:5,//挽留用户看视频给体力\r\n    watchVideoCallBack:null,//当前的视频回调显示\r\n}\r\n\r\n\r\nclass fruitMachine{\r\n    constructor(){  \r\n        this.init();\r\n        this.bin(); \r\n      \r\n    }\r\n     /**\r\n     *初始化使用\r\n     */\r\n    init(){ \r\n\r\n        gameInfo.key = this.getURLParameter().userId ||  gameInfo.key ;\r\n        console.log('当前储存的keygameInfo.key:', gameInfo.key);\r\n        window._globalPointReport = function() {}//重写这个趣淘金的方法\r\n        console.log('当前版本是0.0.9')\r\n        this.initVideosSDKBack();\r\n        //首先取到本地记录 初始化相关的数据\r\n        this.getlocalData();\r\n        //----变量创建区----\r\n        //玩家当前的体力值 \r\n        this.strengthNum = 0;  \r\n        //玩家当前关卡还可以使用的刀子的数量 每使用一个 就会减少一个\r\n        this.haveKnifeNum = 0;\r\n        //玩家先择的游戏奖信息\r\n        this.chooseRwardInfo = null;\r\n        //当前游戏倒计时\r\n        this.gameTimeNum = 0;\r\n        //玩家通成功还是失败的状态  0 还在游戏中未触发成功或者失败的状态(可以继续玩耍)  1 通关成功 2通关失败\r\n        this.levenEndStatus = 0;\r\n        //玩家发射完毕后刀子的相关事项是否处理完毕 true放可以进行发射 包括刀子的预制 刀子数量相应减少\r\n        this.canLaunchStatus = false;\r\n        //倒计时停止倒计时状态  道具看视频使用的 看了 视频倒计时停止\r\n        this.timerIsStop = false; \r\n        //游戏帧的积累 用于阻碍转盘的减速\r\n        this.gameFrame = 0;\r\n        //能发送埋点4001的埋点 用户参与 是第一关且第一次发射刀子\r\n        this.canSen4001=false;//第一关 且这个状态为true 才能发射刀子  所以放在了Game场景里面，这个方法只有从Main进入Game场景的时候才会被调用\r\n\r\n        \r\n        //取到页面上的相关按钮\r\n        this.getBtnNode();\r\n        //绑定出视图与数据区\r\n        this.setPropertyInit(); \r\n        // this.processBool = false;//当前是不是正式服 埋点发送地址\r\n        //初始化数据\r\n        this.strengthNum  = localStorage.strengthNum; \r\n       \r\n\r\n  \r\n        //跑马灯\r\n        this.horseRaceLamp();\r\n        //初始化游戏场景\r\n        this.initGameScene();  \r\n        //按钮状态初始化\r\n        this.Btn1EventInit();\r\n        this.Btn2EventInit();\r\n\r\n        this.turntableJump();\r\n\r\n        //生成中间转盘掉落的动画页面\r\n        this.turntableFallDown();\r\n  \r\n \r\n        //检测今天有没出现过挽留\r\n        if(!localStorage.standBtnTopNum){\r\n                //拦截返回按钮的事件\r\n                let setBackBtn={ \r\n                    pushHistory() { \r\n                    　　var state = { \r\n                    　　　　title: \"title\", \r\n                    　　　　url: \"#\"\r\n                    　　}; \r\n                    　　window.history.pushState(state, \"title\", \"#\"); \r\n                    }\r\n                } \r\n                setBackBtn.pushHistory();\r\n                window.addEventListener(\"popstate\", ()=> { \r\n                    this.showStandPupop(true);\r\n                }, false); \r\n        }\r\n\r\n        //埋点的曝光发送\r\n        this.sendPonit(3);//\r\n\r\n        //使用防抖函数 方式视频播放短时间没多次点击\r\n        this.watchVideosBtnEvent = this.throttle(()=>{\r\n            console.log('前往拉取视频');\r\n            window.location.href=\"qtj://profession/playH5Video?url=\"\r\n        },8000) \r\n    }  \r\n    \r\n     /**\r\n     * 按钮绑定专用\r\n     */  \r\n    bin(){  \r\n\r\n        //添加体力的按钮\r\n        this.setBtn('#add-strength-btn',()=>{\r\n            this.mainSceneBtnEvent(rewardList.reward1);\r\n            // window.location.href = 'https://dev-test-space.oss-cn-hangzhou.aliyuncs.com/dist01/IATest/private/yini/dist/index.html';\r\n        })\r\n        //免费玩耍的按钮\r\n        this.setBtn('#reward-1-play-btn',()=>{\r\n            this.mainSceneBtnEvent(rewardList.reward2);\r\n        }) \r\n        //添加奖品按钮事件\r\n        this.setBtn('#reward-2-play-btn',()=>{\r\n            this.mainSceneBtnEvent(rewardList.reward3);\r\n        }) \r\n        //添加奖品按钮事件\r\n        this.setBtn('#reward-3-play-btn',()=>{\r\n            this.mainSceneBtnEvent(rewardList.reward4);\r\n        }) \r\n        //添加奖品按钮事件\r\n        this.setBtn('#reward-4-play-btn',()=>{\r\n            this.mainSceneBtnEvent(rewardList.reward5);\r\n        }) \r\n        //添加奖品按钮事件\r\n        this.setBtn('#reward-5-play-btn',()=>{\r\n            this.mainSceneBtnEvent(rewardList.reward6);\r\n        }) \r\n        //添加奖品按钮事件\r\n        this.setBtn('#reward-6-play-btn',()=>{\r\n            this.mainSceneBtnEvent(rewardList.reward7);\r\n        }) \r\n        //刀子的发射\r\n        _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#knife-send-btn').click(()=>{ \r\n            this.sendKnife(); \r\n        })\r\n        //失败的窗中 看视频立即复活按钮\r\n        _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#fail-pupop-btn-1').click(()=>{ \r\n            this.watchVideosSDK(watchVideosType.continueGame,()=>{\r\n                this.initPassInfo(localStorage.passNum);\r\n                //关闭提示弹窗\r\n                this.isFailPupop(false);\r\n                //将减速道具设置为已经\r\n                console.log('看视频从本官卡直接复活:',this.passNum);\r\n            })\r\n        }) \r\n        //通关失败返回主页面\r\n        this.setBtn('#fail-pupop-btn-2',()=>{\r\n            this.openMainScene();\r\n        })  \r\n        //玩家试玩成功返回主页面\r\n        this.setBtn('#test-pupop-btn-1',()=>{\r\n            this.openMainScene();\r\n        })   \r\n        //玩家通关成功了\r\n        this.setBtn('#success-pupop-btn',()=>{\r\n            //渠道玩家填写的内容\r\n            let name = document.getElementById('play-name').value;\r\n            let phone = document.getElementById('phone-num').value; \r\n        })   \r\n        //挽留弹窗\r\n        _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#stand-pupop-btn-1').click(()=>{ \r\n            this.watchVideosSDK(watchVideosType.standPlayer,()=>{\r\n               this.addstrengthNum(gameInfo.addStrengthNum);\r\n               this.setlocalData();\r\n               this.showStandPupop(false);\r\n               this.showTipsBox(gameInfo.waring_3); \r\n            })\r\n        })  \r\n        //关闭页面 \r\n        _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#stand-pupop-btn-2').click(()=>{ \r\n            this.showStandPupop(false);\r\n            // window.history.back(-1); \r\n            // window.history.go(-1); //返回上一页\r\n        }) \r\n        // let ceshi =  this.throttle(()=>{\r\n        //     console.log('我被点击了');\r\n        //     this.showRulePupop(true);\r\n        // },3000)\r\n        //规则按钮\r\n        this.setBtn('#rule-btn',()=>{\r\n            //渠道玩家填写的内容\r\n            console.log('我被点击了');\r\n            this.showRulePupop(true);\r\n     \r\n\r\n        })   \r\n        this.setBtn('#reward-btn',()=>{\r\n            //渠道玩家填写的内容 \r\n            this.rewardListPupop(true);\r\n     \r\n\r\n        })   \r\n        this.setBtn('#rule-pupop-close-btn',()=>{\r\n            //渠道玩家填写的内容 \r\n            this.showRulePupop(false);  \r\n        })     \r\n        this.setBtn('#winning-record-close-btn',()=>{\r\n            //渠道玩家填写的内容 \r\n            this.rewardListPupop(false);  \r\n        })  \r\n       \r\n \r\n    }\r\n    //绑定减速按钮事件\r\n    speedBtn(){\r\n        //减速道具 \r\n        this.setBtn('#speed-reduction',()=>{ \r\n            //调取视频\r\n            this.isStopTimer(true);\r\n            this.watchVideosSDK(watchVideosType.shiftDown,()=>{\r\n                this.showTipsBox(gameInfo.waring_2);\r\n                // console.log('使用道具')\r\n                //倒计时停止\r\n                this.isStopTimer(false); \r\n                this.useSpeedProp(2);\r\n                slowDownPropInfo.useStatus = 0;\r\n            })\r\n\r\n        })  \r\n    }\r\n    /**\r\n     * 绑定数据与数据图\r\n     */\r\n    setPropertyInit(){\r\n        this.setProperty(this,'strengthNum',localStorage.strengthNum,(vlue)=>{\r\n            console.log('strengthNum:',vlue);\r\n            if(vlue<=0){\r\n                vlue = 0;\r\n            }\r\n             _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#strength-num').text(vlue);\r\n             this.dealWithStrengthNum(vlue);\r\n        }); \r\n     \r\n        this.setProperty(localStorage,'whatchVideoNum',localStorage.whatchVideoNum,(vlue)=>{\r\n            console.log('whatchVideoNum:',vlue); \r\n            this.Btn1EventInit();\r\n        }); \r\n\r\n        this.setProperty(localStorage,'canfreePlay',localStorage.canfreePlay,(vlue)=>{\r\n            console.log('canfreePlay:',vlue); \r\n            this.Btn2EventInit();\r\n        }); \r\n\r\n        this.setProperty(localStorage,'passNum',localStorage.passNum,(vlue)=>{\r\n            console.log('passNum:',vlue); \r\n            this.dealWithpass(vlue);\r\n        }); \r\n        \r\n        //当前关卡拥可以发生的刀子的数量\r\n        this.setProperty(this,'haveKnifeNum',0,(vlue)=>{\r\n            // console.log('haveKnifeNum:',vlue); \r\n            //初始化当前可使用的刀子的数量\r\n            this.showHaveKniefNum(vlue); \r\n        });    \r\n\r\n        //当前关卡通关是失败还是成功的状态\r\n        this.setProperty(this,'levenEndStatus',0,(vlue)=>{\r\n            console.log('levenEndStatus:',vlue); \r\n            this.customsPassStatus(vlue,this.chooseRwardInfo,localStorage.passNum); \r\n          \r\n        });   \r\n        //减速道具\r\n        this.setProperty(slowDownPropInfo,'useStatus',1,(vlue)=>{\r\n            console.log('useStatus:',vlue);  \r\n            this.useSpeedProp(vlue);\r\n        \r\n        });  \r\n      \r\n\r\n    }\r\n    /**\r\n     * 发射刀子\r\n     */\r\n    sendKnife(){\r\n        if(this.haveKnifeNum === 0){\r\n            console.log('玩家当前已经没有刀子了');\r\n            return;\r\n        }\r\n        //有刀子切是可以发射的状态\r\n        if( this.knife && this.canLaunchStatus){ \r\n            //关掉玩法提示\r\n            this.showImgWaring(-1);\r\n            // this.knifeNumArry.push(this.knife);//将刀子放到碰撞检测中\r\n            this.knife.isCanMove = true; //打开刀子的移\r\n            this.canLaunchStatus = false;  //发射后将刀子的准备状态设置为false\r\n        }\r\n        if(this.canSen4001 && localStorage.passNum===1 ){\r\n            this.canSen4001=false;\r\n            this.sendPonit(4);//用户参与埋点\r\n        }\r\n    \r\n    }\r\n    /**\r\n    *  打开游戏的场景\r\n    * @param {*} rewardList \r\n    */ \r\n    \r\n    openGameScene(rewardList,BACK = null){\r\n        //当前的奖品的信息\r\n        this.chooseRwardInfo = rewardList;\r\n        //设置当前关卡数 游戏挂卡中的动态信息 在 localStorage.passNum 中\r\n        // localStorage.passNum = 1; \r\n        //更新右上角的奖品\r\n        this.showReWardTitle(rewardList.content);\r\n        //打开游戏场景\r\n        this.isOpenMainScene(false); \r\n        //初始化相关数据\r\n        this.initPassInfo(1);\r\n        //引导玩家点击发射刀子\r\n        this.showImgWaring(1);\r\n        //将减速道具设置为可以使用\r\n        // this.useSpeedProp(1);\r\n        slowDownPropInfo.useStatus = 1;\r\n        //将发送埋点的状态放开\r\n        this.canSen4001 = true;//在刀子发射中使用\r\n        //回调方法 \r\n        if(BACK!=null){\r\n            BACK();\r\n        } \r\n    }\r\n    /**\r\n     * 打开主页面场景\r\n     */\r\n    openMainScene(){\r\n        this.isOpenMainScene(true);\r\n        this.closeAllPupop();\r\n        this.cleanKnifeArry();//转盘清空\r\n    }\r\n \r\n    /**\r\n     * 是否打开main场景\r\n     * @param {bool} _bool \r\n     */\r\n    isOpenMainScene(_bool){\r\n        let mainScene = _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#main-scene');\r\n        let ganeScene = _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#game-scene');\r\n        if(_bool){\r\n            mainScene.show();\r\n            ganeScene.hide();\r\n        }else{\r\n            ganeScene.show();\r\n            mainScene.hide();\r\n        }\r\n\r\n    } \r\n    //-------------------mainScene部分----------\r\n    /**\r\n     * 取到页面上的相关按钮\r\n     */\r\n    getBtnNode(){\r\n        gameInfo.btin_1 = _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#add-strength-btn');\r\n        gameInfo.btin_2 = _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#reward-1-play-btn');\r\n        gameInfo.btin_3 = _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#reward-2-play-btn');\r\n        gameInfo.btin_4 = _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#reward-3-play-btn');\r\n        gameInfo.btin_5 = _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#reward-4-play-btn');\r\n        gameInfo.btin_6 = _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#reward-5-play-btn');\r\n        gameInfo.btin_7 = _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#reward-6-play-btn');\r\n        \r\n        \r\n        gameSceneUI.starts_1 =  _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#list-1');\r\n        gameSceneUI.starts_2 =  _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#list-2');\r\n        gameSceneUI.starts_3 =  _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#list-3');\r\n        gameSceneUI.starts_4 =  _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#list-4');\r\n        gameSceneUI.rewardTitle =  _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#reward-content');\r\n    \r\n    }\r\n    /**\r\n     * 处理主场景的btn事件\r\n     * @param {number} type \r\n     */\r\n    mainSceneBtnEvent(reward){\r\n\r\n        let type = reward.id; \r\n\r\n        if(type === rewardList.reward1.id){\r\n            this.Btn1Event(reward);\r\n        }else if(type === rewardList.reward2.id){\r\n            this.btn2Event(reward);\r\n        }else if(type>=rewardList.reward3.id){\r\n            this.btnRwardEvent(reward);\r\n        } \r\n        //将数据储存在本地\r\n        this.setlocalData();\r\n    }\r\n    /**\r\n     * 当前的按钮初始化状态\r\n     */\r\n    Btn1EventInit(){\r\n      //玩家当前是不是看视频增加体力\r\n        if(localStorage.whatchVideoNum > gameInfo.whatchVideoTopNum){\r\n            gameInfo.btin_1.addClass('gray');\r\n            gameInfo.btin_1.off();\r\n        }\r\n      \r\n    }\r\n    /**\r\n     *试玩的按钮初始化状态 \r\n     */\r\n    Btn2EventInit(){\r\n        //玩家之前是不是试玩过了 是的话 今天就不可以再试玩了\r\n        if(localStorage.canfreePlay === 0){\r\n            gameInfo.btin_2.addClass('gray');\r\n            gameInfo.btin_2.off();\r\n        }  \r\n    }\r\n    /**\r\n     * 获取更多体力显示的 最对点击8次 超过了就不可以再进行点击了  置灰处理\r\n     */\r\n    Btn1Event(){ \r\n        if(localStorage.whatchVideoNum<=gameInfo.whatchVideoTopNum){ \r\n            this.watchVideosSDK(watchVideosType.getStrengthNum,()=>{\r\n                //将减速道具设置为已经\r\n                localStorage.whatchVideoNum++;\r\n                this.addstrengthNum(gameInfo.addStrengthNum)\r\n                console.log('玩家唤起视频，增加体力');\r\n            })\r\n        }else{\r\n            console.log('玩家不能唤起视频，增加体力');\r\n        }\r\n        \r\n    }\r\n    /**\r\n     * 按钮2 --试玩按钮的处理\r\n     * @param {object} reward \r\n     */\r\n    btn2Event(reward){\r\n        if(localStorage.canfreePlay ===  1){\r\n            this.openGameScene(reward)\r\n            console.log('玩家开始免费试玩')\r\n        }else{\r\n            console.log('玩家不能开始免费试玩')\r\n        }\r\n        //游戏玩完了 就将状态设置为当前不可以再玩游戏了\r\n        localStorage.canfreePlay = 0;\r\n    } \r\n    /**\r\n     * 选择固定奖品的游戏进行挑战\r\n     * @param {object} rewardList \r\n     */\r\n    btnRwardEvent(rewardList){\r\n\r\n        //体力值大于等于2 可以开始游戏\r\n        if(this.strengthNum>=gameInfo.playCostStrengthNum){\r\n            //打开游戏场景 \r\n            this.openGameScene(rewardList,()=>{ \r\n                //减去点体力值作为门票 \r\n                this.addstrengthNum(-gameInfo.playCostStrengthNum); \r\n            });\r\n            console.log('可以直接开始游戏,活动的将奖品id是',rewardList)\r\n        }else{ \r\n            this.watchVideosSDK(watchVideosType.playerGame,()=>{\r\n                //将减速道具设置为已经\r\n                 console.log('没有体力使用看视频充体力,看视频开始游戏');\r\n                 this.openGameScene(rewardList,()=>{ \r\n                     console.log('进入玩游戏啦~');\r\n                    //减去点体力值作为门票 \r\n                    // this.addstrengthNum(-gameInfo.playCostStrengthNum); \r\n                });\r\n            })\r\n            // //体力值小于2 则打开调取看视频玩游戏的逻辑\r\n            // console.log('不可以直接开始游戏,玩家的体力值不够,活动的将奖品id是',rewardList)\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     *处理体力值 从而对按钮显示不同状态\r\n     * @param {number} num 当前生于的体力数量\r\n     */\r\n    dealWithStrengthNum(num){\r\n        let deal = {\r\n            changeBtn:function(node){\r\n                if(num<=0){\r\n                    this.btn_watchVideos(node); \r\n                    this.btn_1();\r\n                }else{\r\n                    this.btn_playGamw(node);\r\n                }\r\n            },\r\n            btn_watchVideos:function(node){\r\n                node.removeClass();\r\n                node.addClass('continue_btn_T')\r\n            },\r\n            btn_playGamw:function(node){\r\n                node.removeClass();\r\n                node.addClass('play_btn_T')\r\n            },\r\n            btn_1:function(){\r\n                gameInfo.btin_1.removeClass()\r\n                gameInfo.btin_1.addClass('more-btn-T-1');\r\n            }\r\n        } \r\n        //对按钮的状态进行处理\r\n        deal.changeBtn(gameInfo.btin_3);\r\n        deal.changeBtn(gameInfo.btin_4);\r\n        deal.changeBtn(gameInfo.btin_5);\r\n        deal.changeBtn(gameInfo.btin_6);\r\n        deal.changeBtn(gameInfo.btin_7); \r\n\r\n        \r\n \r\n\r\n    }\r\n    // --------------------gameScene部分------------\r\n    initGameScene(){\r\n        let self = this;//为了下面能够使用\r\n        let turntableBox = 'turntable-box';\r\n        this.isTopGame = false;//是不是停止游戏\r\n        this.playerIsfail = false;//检测游戏是不是失败了 失败就不在生成刀子了\r\n        this.turntableRotate={//大转盘旋转的角度 为了能让刀子对象时时的取到 于是使用了obj指向内存的属性 可以时时取到最新的角度信息\r\n            num:0             //同时也是初始化 角度\r\n        };\r\n        this.knifeNumArry = [];//当前的数组 放刀子的数据 \r\n        this.knifeConfig = {//预制刀子的配置\r\n            bornAreaID:'game-scene',//生成在什么节点下\r\n            id: self.knifeNumArry.length,//传入生成的id\r\n            parentID:turntableBox, //刀子插入的大转盘的id \r\n            radiusRatio:0.25,//半径的比值 一半小于0.5是刀子正好插在边上 取值范围(0,0.5]\r\n            knifeList: self.knifeNumArry,//将数组传进去 刀子插入转盘的时候 加入到这个数组中去\r\n            node:{//刀子旋转与定位到了圆里面的信息\r\n                rotate:self.turntableRotate,//当前大转盘的角度\r\n                width:286,//大转盘的宽 这个是大转盘#gs-turntable 里面css设置的宽高的1/2  290 -> 0.215\r\n                height:286,//大转盘的高 290 -> 0.32\r\n            }\r\n        };\r\n        let turntable = document.getElementById(turntableBox); \r\n        let turntableT = document.getElementById('turntable-box-T'); \r\n        this.setProperty(this.turntableRotate,'num',this.turntableRotate.num,(vlue)=>{ \r\n             turntable.style.webkitTransform=`rotate(${vlue}deg)`;  \r\n             turntableT.style.webkitTransform=`rotate(${vlue}deg)`; \r\n        })\r\n  \r\n        this.updata();\r\n        \r\n    }\r\n    //预制刀子  生成新的数据\r\n    prefabKinfeObj(){  \r\n        //玩家没有失败或者通关 或者玩家没有可是使用的刀子的数量了  \r\n        if(this.isStopGame() || this.haveKnifeNum === 0) return;\r\n        //延时用于检测有没有碰撞 -- 因为预制出来新的刀子后就检测的是新的刀子与转盘上的刀子 就不在检测之前的刀子是不是与转盘上的刀子碰撞\r\n        setTimeout(()=>{    \r\n            if(this.isStopGame() || this.haveKnifeNum === 0) return;\r\n            this.knife = new _Knife_js__WEBPACK_IMPORTED_MODULE_2__[\"Knife\"](this.knifeConfig,this.knifeNumArry.length,()=>{  \r\n                //减去刀子的数量\r\n                this.haveKnifeNum --; \r\n                //如果没有刀子了说玩家通关成功了\r\n                if(this.haveKnifeNum === 0) {\r\n                    setTimeout(()=>{ \r\n                        //延迟相应毫秒检测碰撞--会出现一种情况 最后一个刀子的碰撞 是先处理通关还是先处理碰撞？  先处理有无碰撞 再处理有没有通关\r\n                        this.canChangeGameStatus(1); \r\n                       \r\n                    },gameInfo.prefabKinfeDelayNum)\r\n                    return\r\n                }  \r\n                //插入转盘的跳动\r\n                // this.jumpAnimation();\r\n                //生成信息的刀子\r\n                this.prefabKinfeObj();  \r\n            }); \r\n          //刀子与相关UI准备完毕 可以发射\r\n          this.canLaunchStatus = true;//刀子可以发射了\r\n        },gameInfo.delayNum); \r\n    }\r\n    /**\r\n     *清除飞刀与数组所占的内存\r\n     */\r\n    cleanKnifeArry(){ \r\n        this.knifeNumArry.forEach((element)=>{\r\n            element.isRemove();\r\n         });\r\n         //移除当前的刀子\r\n         if(this.knife){\r\n            this.knife.isRemove()\r\n         }\r\n         this.knife = null;\r\n         this.knifeNumArry = [];\r\n         console.log('数组被清空了',this.knife);\r\n    }\r\n    //刀子数组的碰撞检测\r\n    checkKinfeArry(){\r\n        if( this.knifeNumArry.length <2) return; \r\n        this.knifeNumArry.forEach((element)=>{ \r\n            //检测有无刀子\r\n            if(this.knife === null ||  this.knife === undefined || this.knife === '') return;\r\n                //检测当前是不是对比的本身的刀子\r\n                if(this.knife.id === element.id){\r\n                    return;\r\n                }   \r\n               var knifeInfo = this.knife.objctknifeInfo.offset();\r\n               var elementInfo = element.objctknifeInfo.offset();  \r\n               if(this.checkCrash(knifeInfo,elementInfo) === true){\r\n                    this.canChangeGameStatus(2);\r\n                    console.log('刀子相撞了',this.knife.id,element.id,knifeInfo,elementInfo);   \r\n               } \r\n        })  \r\n    }\r\n    /**\r\n     * 当前关卡设置的事件\r\n     * @param {number} num 传入当前是第几关卡\r\n     */\r\n    dealWithpass(num){\r\n        //对转盘进行调整\r\n        this.changeSpeed()\r\n        //显示左上角的关卡数量\r\n        this.showPassStarts(num); \r\n        this.showPassNum(num);\r\n\r\n        //检查关卡数是不是超过了本奖品的最大关卡数 是的话 出现弹窗提示\r\n        if(num > this.chooseRwardInfo.maxPassNum){\r\n            console.log(gameInfo.waring_1);\r\n            return;\r\n        } \r\n        console.log('当前关卡应该有的数量:',num,this.chooseRwardInfo.passKnifeNumList[num-1])\r\n        //初始化当前的刀子的数量\r\n        this.haveKnifeNum = this.chooseRwardInfo.passKnifeNumList[num-1]; \r\n        \r\n        //初始化倒计时时间\r\n        this.showTimerNum(this.chooseRwardInfo.timeNumList[num-1],()=>{ \r\n            //倒计时结束 游戏闯关失败\r\n           this.canChangeGameStatus(3);\r\n            console.log('倒计时结束');\r\n\r\n        })\r\n    }\r\n    /**\r\n     * 检测当前是不是可以进行更改游戏额状态  0 游戏中 1通关 2碰撞失败 3是倒计时到了闯关失败 \r\n     * @param {number} num \r\n     */\r\n    canChangeGameStatus(num){\r\n        if(this.levenEndStatus===0){\r\n            //当前状态在游戏中\r\n            this.levenEndStatus = num //游戏结束 通关了 所以状态是1\r\n            //通关成功打开大转盘两半的动画\r\n            if(num === 1){\r\n                 //打开大转盘掉落的动画\r\n                 this.turntableDoAni();\r\n            }\r\n        } else{\r\n            console.log('无法更换游戏状态因为 已经是',this.levenEndStatus,'两个状态不能同时存在')\r\n        }    \r\n        return \r\n    }\r\n    /**\r\n     * 左上角 当前的关卡数是多少  例如 第一关 第二关 第三关 第四关 \r\n     * @param {number} num \r\n     */\r\n    showPassNum(num){\r\n       let node = _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#pass-title');\r\n       node.removeClass().addClass(`pass-title-${num}`);\r\n    }\r\n    /**\r\n     * 展示星星关卡数  左上角 当前的关卡数是多少\r\n     * @param {number} num \r\n     */\r\n    showPassStarts(num){ \r\n       let  dealWite={\r\n           //更新星星的数量\r\n            changeStatsY:function(node){\r\n                node.removeClass();\r\n                node.addClass('passdStart_y')\r\n            },\r\n            changeStatsN:function(node){\r\n                node.removeClass();\r\n                node.addClass('passdStart_n')\r\n            },\r\n       }\r\n       num -=1;\r\n       dealWite.changeStatsN(gameSceneUI.starts_1)\r\n       dealWite.changeStatsN(gameSceneUI.starts_2)\r\n       dealWite.changeStatsN(gameSceneUI.starts_3)\r\n       dealWite.changeStatsN(gameSceneUI.starts_4)\r\n       if(num === 1){\r\n            dealWite.changeStatsY(gameSceneUI.starts_1) \r\n       }else if(num === 2){\r\n            dealWite.changeStatsY(gameSceneUI.starts_1) \r\n            dealWite.changeStatsY(gameSceneUI.starts_2) \r\n       }else if(num === 3){\r\n            dealWite.changeStatsY(gameSceneUI.starts_1) \r\n            dealWite.changeStatsY(gameSceneUI.starts_2) \r\n            dealWite.changeStatsY(gameSceneUI.starts_3) \r\n        }else if(num === 4){\r\n            dealWite.changeStatsY(gameSceneUI.starts_1) \r\n            dealWite.changeStatsY(gameSceneUI.starts_2) \r\n            dealWite.changeStatsY(gameSceneUI.starts_3) \r\n            dealWite.changeStatsY(gameSceneUI.starts_4) \r\n        } \r\n    }\r\n    \r\n    /**\r\n     * 在游戏的右上角展示当前的奖品内容\r\n     * @param {string} content \r\n     */\r\n    showReWardTitle(content){\r\n        gameSceneUI.rewardTitle.text(content);\r\n    }\r\n\r\n    /**\r\n     * 当前通关的状态  1=成功  2=失败\r\n     * @param {number} num \r\n     * @param {object} chooseRwardInfo 奖品的内容chooseRwardInfo \r\n     * @param {number} passNum 当前是第几关卡 \r\n     */\r\n    customsPassStatus(num,chooseRwardInfo,passNum){ \r\n        // successPupopDelayNum:1000,//闯关成功 最后获奖了 显示弹窗的延迟倒计时 （要留给通关钱转盘的动画时间）\r\n        // failPupopDelayNum:200,//通关失败中的延迟出现通关的弹窗时间\r\n        // passPupopDelayNum:1000,//正常通关中的延迟出现通关的弹窗时间（要留给通关钱转盘的动画时间）\r\n        let timeNum = 1000;\r\n        if(num!==0){\r\n            this.timerOver() \r\n        }\r\n        let gameType = 0;\r\n        if( num === 1 ){\r\n            timeNum = gameInfo.passPupopDelayNum;\r\n            gameType = this.getShowPupopTyp(passNum,chooseRwardInfo); \r\n        }else if( num === 2 ){//玩家是碰撞到了 刀子后失败的\r\n            gameType = 3\r\n            // 策划说失败的弹窗出现的延迟时间太久了 所以我在这里 进行处理\r\n            timeNum = gameInfo.failPupopDelayNum;\r\n        }else if( num === 3 ){ //玩家是倒计时失败的\r\n            gameType = 5\r\n            // // 策划说失败的弹窗出现的延迟时间太久了 所以我在这里 进行处理\r\n            timeNum = gameInfo.failPupopDelayNum;\r\n        }\r\n\r\n        \r\n        //传动给弹窗弹窗分析器 \r\n        setTimeout(()=>{\r\n            this.showPupop(gameType,passNum)\r\n        },timeNum)\r\n        \r\n         \r\n    }\r\n    /**\r\n     * 得到当前应该展示的弹窗的类型\r\n     * @param {number} num \r\n     * @param {object} chooseRwardInfo  \r\n     */\r\n    getShowPupopTyp(passNum,chooseRwardInfo){\r\n        //0 没有意义   1 试玩成功 2通关成功 3 通关失败 4得到奖品 5倒计时结束失败\r\n        let type = 0 ;\r\n        //检测当前是模式  试玩？ 奖品？\r\n        if(chooseRwardInfo.typeOfPlay === rewardList.testPlayType){\r\n            //试玩模式\r\n            if(passNum<chooseRwardInfo.maxPassNum){\r\n                type = 2;\r\n            }else{\r\n                type = 1;\r\n            } \r\n            console.log('当前是测试：给出来的相关数据',type,'关卡是:',passNum);\r\n        }else if(chooseRwardInfo.typeOfPlay === rewardList.rewardtPlayType){\r\n            // 奖品模式\r\n            if(passNum<chooseRwardInfo.maxPassNum){\r\n                type = 2;\r\n            }else{\r\n                type = 4;\r\n            } \r\n        }\r\n\r\n        return type\r\n\r\n    }\r\n    /**\r\n     * 展示相关的弹窗\r\n     * @param {number} num  0 没有意义   1 试玩成功 2通关成功 3 通关失败 4得到奖品 5倒计时结束失败\r\n     * @param {number} passNum 当前的关卡数\r\n     */\r\n    showPupop(num,passNum){\r\n        if(num === 1){\r\n            this.showTestGamePupop(true); \r\n        }else if(num === 2){ \r\n         \r\n            this.isSuccessPupop(passNum); \r\n        }else if(num === 3){\r\n            this.isFailPupop(1,true); \r\n        }else if(num === 4){\r\n            this.showSuccessGamePupop(true); \r\n        }else if(num === 5){\r\n            this.isFailPupop(2,true); \r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     *展示当前刀子的数量\r\n     * @param {unmber} num \r\n     */\r\n    showHaveKniefNum(num){\r\n        let shi_node = _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()(\"#knife-num-decade\");\r\n        let ge_node = _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#knife-num-bit');\r\n        if(num>=10 && num<100){ \r\n            shi_node.show();\r\n            shi_node.removeClass().addClass(`num_${parseInt(num/10)}`);\r\n        }else{\r\n            shi_node.hide();\r\n        } \r\n        ge_node.removeClass().addClass(`num_${num%10}`);\r\n    }\r\n    /**\r\n     * 倒计时的处理\r\n     * @param {number} num \r\n     */\r\n    showTimerNum(num,BACK=null){\r\n        let timer = _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#game-timer'); \r\n        //取消倒计时\r\n        this.timerOver();\r\n        //时间初始化\r\n        this.showSurplusTime(timer,num);\r\n        //时间倒计时\r\n        this.gameTimer = setInterval(()=>{ \r\n            if(this.timerIsStop){\r\n                return;\r\n            }\r\n            num--; \r\n            this.showSurplusTime(timer,num);\r\n            //倒计时完毕的回调\r\n            if(BACK!=null && num<=0){\r\n                BACK();\r\n            }\r\n            //倒计时结束的取消倒计时\r\n            if(num<=0){\r\n                this.timerOver();\r\n            }\r\n        },1000) \r\n    }\r\n    /**\r\n     * 结束倒计时倒计时\r\n     */\r\n    timerOver(){\r\n        //取消倒计时\r\n        if(this.gameTimer){\r\n            clearInterval(this.gameTimer);\r\n        } \r\n    }\r\n   /**\r\n    * 停止倒计时\r\n    * @param {boolean} bool  true 停止倒计时  false继续倒计时\r\n    */\r\n    isStopTimer(bool = false){\r\n        this.timerIsStop = bool;\r\n    }\r\n\r\n    /**\r\n     * 时间的补位  \r\n     * @param {number} num \r\n     */\r\n    patchPosition(num){\r\n        let _num = num.toString();\r\n        if(num<10){\r\n            _num = '0'+_num;\r\n        }\r\n        return _num;\r\n    }\r\n    /**\r\n     *  展示剩余时间\r\n     * @param {node} timerNode \r\n     * @param {number} num \r\n     */\r\n    showSurplusTime(timerNode,num){\r\n        //计算剩余时间  时间展示上线是59:69\r\n        let minute = this.patchPosition(parseInt( num/60));\r\n        let second =this.patchPosition(num%60); \r\n        timerNode.text(minute+':'+second);  \r\n    }\r\n   /**\r\n    * 成功通关了 当前显示的是第几关卡\r\n    * @param {number} num \r\n    */\r\n    isSuccessPupop(num){   \r\n        let node =  _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#successfulEntry');\r\n        //三个动态的星星\r\n        let node_starts1 =  node.find('#pupop-Stars-1');\r\n        let node_starts2 =  node.find('#pupop-Stars-2');\r\n        let node_starts3 =  node.find('#pupop-Stars-3');\r\n        this.pupopAnimation(node);\r\n        _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#popup-num').removeClass().addClass(`pupop_num_${num+1}`);\r\n        node.css('display','inline')\r\n        setTimeout(()=>{ \r\n            let _num = num + 1 ;\r\n            this.initPassInfo(_num);\r\n            node.css('display','none');\r\n            //关掉三个星星\r\n            node_starts1.css('display','none');\r\n            node_starts2.css('display','none');\r\n            node_starts3.css('display','none');\r\n        },2000); \r\n        let animationType = 'zoomInDown';//被使用的动画类型\r\n        //延时出现动画\r\n        this.startsSetTimeout(node_starts1,animationType,700)\r\n        this.startsSetTimeout(node_starts2,animationType,800)\r\n        this.startsSetTimeout(node_starts3,animationType,900)\r\n    }\r\n    /**\r\n     * 显示星星的倒计时\r\n     * @param {objject} node  节点\r\n     * @param {string} animationType 动画类型\r\n     * @param {number} timeNum 时间\r\n     */\r\n    startsSetTimeout(node,animationType,timeNum=100){\r\n        setTimeout(()=>{\r\n            node.css('display','inline');\r\n            this.nodeAnimation(node,animationType,250)\r\n        },timeNum)\r\n        \r\n    }\r\n    /**\r\n     * 展示失败的弹窗\r\n     * @param {number}  typeNum 失败的类型\r\n     * @param {boolean} bool \r\n     */\r\n    isFailPupop(typeNum,bool=false){\r\n        let node = _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#fail-game-pupop');\r\n        let pupopClass = 'pass-game-fail'\r\n        if(typeNum === 2){\r\n            pupopClass = 'pass-time-over'\r\n        }\r\n        node.find('#popup').removeClass().addClass(pupopClass);\r\n        this.pupopAnimation(node);\r\n        if(bool){\r\n            node.css('display','inline')\r\n        }else{\r\n            node.css('display','none')\r\n        }\r\n    }\r\n   /**\r\n    * 试玩通关 弹窗\r\n    * @param {boolean} bool  true=打开弹窗  false关闭弹窗\r\n    */\r\n    showTestGamePupop(bool=false){\r\n        let node = _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#test-game-pupop');\r\n        this.pupopAnimation(node);\r\n        if(bool){\r\n            node.css('display','inline')\r\n        }else{\r\n            node.css('display','none')\r\n        } \r\n    } \r\n    /**\r\n     * 展示玩家通关的页面 \r\n     * @param {boolean} bool \r\n     */\r\n    showSuccessGamePupop(bool = false){\r\n        let node = _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#success-game-pupop');\r\n        this.pupopAnimation(node);\r\n        if(bool){\r\n            node.css('display','inline')\r\n        }else{\r\n            node.css('display','none')\r\n        } \r\n    }\r\n    /**\r\n     * 显示当前的挽留弹窗\r\n     * @param {boolean} bool \r\n     */\r\n    showStandPupop(bool = false){\r\n        localStorage.standBtnTopNum--;\r\n        let node = _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#stand-pupop'); \r\n        this.pupopAnimation(node);\r\n        if(bool){ \r\n            node.css('display','inline')\r\n        }else{\r\n            node.css('display','none')\r\n        } \r\n        //将数据进行保存\r\n        this.setlocalData();\r\n    }\r\n    /**\r\n     * 显示出来规则的弹窗\r\n     * @param {boolean} bool \r\n     */\r\n    showRulePupop(bool = false){\r\n        let node = _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#rule-pupop'); \r\n        this.pupopAnimation(node);\r\n        if(bool){ \r\n            node.css('display','inline')\r\n        }else{\r\n            node.css('display','none')\r\n        }  \r\n    }\r\n    /**\r\n     * 玩家奖励的列表显示\r\n     * @param {boolean} bool \r\n     */\r\n    rewardListPupop(bool = false){\r\n        let node = _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#winning-record-pupop'); \r\n        this.pupopAnimation(node);\r\n        if(bool){ \r\n            node.css('display','inline')\r\n        }else{\r\n            node.css('display','none')\r\n        }  \r\n    }\r\n\r\n    /**\r\n     * 关闭游戏中的所有的弹窗\r\n     */\r\n    closeAllPupop(){\r\n        _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#test-game-pupop').css('display','none');\r\n        _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#fail-game-pupop').css('display','none');\r\n        _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#successfulEntry').css('display','none');\r\n        _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#success-game-pupop').css('display','none');\r\n    }\r\n    /**\r\n     * 返回当前是不是停止游戏\r\n     */\r\n    isStopGame(){\r\n        let bool = false;\r\n        if(this.levenEndStatus !== 0){\r\n            bool = true\r\n        }\r\n        return bool;\r\n    }\r\n    //大转盘进行上下抖动\r\n    turntableJump(){\r\n        let turntable1 = _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#turntable-box');\r\n        let turntable2 = _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#turntable-box-T');\r\n\r\n        console.log('当前的坐标:',turntable1.position(),_node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#test').css('top'))\r\n        // let top1={\r\n        //     top: '-0.2rem'\r\n        // }\r\n        // let top2={\r\n        //     top:'0.2rem'\r\n        // }\r\n        // let top3={\r\n        //     top:'0rem'\r\n        // }\r\n        // turntable2.animate(top1,50,()=>{\r\n        //     turntable2.animate(top2,50,()=>{\r\n        //         turntable2.animate(top3,50,()=>{\r\n        //             this.turntableJump();\r\n        //         })\r\n        //     })\r\n        // })\r\n\r\n    }\r\n   /**\r\n    * 初始化当前关卡的信息\r\n    * @param {number} num 传入关卡数更新当前相关关卡的数据与准备信息 \r\n    */\r\n    initPassInfo(num){\r\n        //如果当前道具是使用中的  就改为已经使用过了。 因为这个道具只能使用一关 \r\n        if(slowDownPropInfo.useStatus === 0){\r\n            slowDownPropInfo.useStatus = 2;\r\n        }\r\n        //关卡数增加\r\n        localStorage.passNum = num; \r\n        //清空大转盘\r\n        this.cleanKnifeArry();\r\n        //让大转盘转动起来\r\n        this.levenEndStatus = 0;\r\n        //预制刀子\r\n        this.prefabKinfeObj();\r\n        //显示大转盘 因为之前可能因为掉落的动画 将大转盘给关掉了\r\n        this.showTurntableBox(true);\r\n \r\n    }\r\n    /**\r\n     * 当前道具的状态 0正在使用中  1可以使用  2已经使用过了 \r\n     * @param {number} num \r\n     */\r\n    useSpeedProp(num){ \r\n        if(num === 1){\r\n            //取消道具使用的按钮事件\r\n            _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#speed-reduction').off();\r\n            //绑定按钮事件\r\n            this.speedBtn() \r\n            _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#speed-reduction').removeClass().addClass('speed-reduction-y');\r\n        }else if(num === 2 || num === 0){//使用过了就去掉按钮的事件\r\n            //取消按钮事件\r\n            _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#speed-reduction').off();\r\n            _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#speed-reduction').removeClass().addClass('speed-reduction-n');\r\n        } \r\n     \r\n    }\r\n    //帧循环事件\r\n    updata(){ \r\n        window.requestAnimationFrame(this.updata.bind(this));\r\n        //大转盘左的动画\r\n        if(this.turntableAni_left){\r\n            this.turntableAni_left.Animation();\r\n        }\r\n        //大转盘右边的动画\r\n        if(this.turntableAni_right){\r\n            this.turntableAni_right.Animation();\r\n        }\r\n        //停止游戏\r\n        if(this.isStopGame()){\r\n            return;\r\n        }\r\n        let speedNum = slowDownPropInfo.normalSpeed;\r\n        //旋转转盘 \r\n        //检测当前的道具状态是不是使用中 是使用中的话 转盘减速\r\n        if(slowDownPropInfo.useStatus === 0){ \r\n            speedNum = speedNum * slowDownPropInfo.speedDowm;\r\n        }\r\n        this.turntableRotate.num += speedNum; \r\n\r\n\r\n        //开始碰撞检测\r\n        this.checkKinfeArry();\r\n       \r\n        //如果刀子插入的大转盘的话 就将他放入碰撞队列之中\r\n        if(this.knife) this.knife.move(()=>{\r\n            this.knifeNumArry.push(this.knife);\r\n        })\r\n    }\r\n    /**\r\n     * 修改当前的转动的方向与速度 \r\n     */\r\n    changeSpeed(){  \r\n        //停止倒计时\r\n        if(this.timerFun) clearTimeout(this.timerFun);\r\n\r\n       \r\n        let  timeNum = slowDownPropInfo.timeNumList[localStorage.passNum-1]; \r\n        let timer =  this.randomFrom( timeNum[0],timeNum[1] );\r\n        // console.log('转动内容进行调整',timer,'范围是:',timeNum,)\r\n        // console.log('当前的倒计时是:',timer);\r\n        //当前的基础转速是多少\r\n        let _num = this.randomFrom(slowDownPropInfo.speedScope[0]*10,slowDownPropInfo.speedScope[1]*10)/10;\r\n        //随机旋转的方向  可以增加一个条件  就是 连续几次相同的方向后 后一个是相反反向 或者是权重加大\r\n        let _rotaotion = this.randomFrom(0,10) >= 5 ? -1 : 1;\r\n        slowDownPropInfo.normalSpeed = _num*_rotaotion;  \r\n\r\n      \r\n        this.timerFun = setTimeout(()=>{\r\n            this.changeSpeed();\r\n        },timer) \r\n    }\r\n\r\n    /**\r\n     * 图片的方式显示警告\r\n     * @param {number} type  -1 是什么都不显示    1->2 是提示的编码\r\n     */\r\n    showImgWaring(type){\r\n        let node = _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#waring-box');\r\n        \r\n        node.removeClass();\r\n        if(type === -1){\r\n            return;\r\n        }\r\n        if(type===1){\r\n            node.addClass('waring-img-1')\r\n        }else if(type===2){\r\n            node.addClass('waring-img-2')\r\n        } \r\n    }\r\n    //------------------------公共方法-----------------\r\n    /**\r\n     *  提示文本框\r\n     * @param {string} content \r\n     */\r\n    showTipsBox(content){\r\n        let node = _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#tips-box');\r\n        node.text(content);\r\n        node.css('display','inline');\r\n        setTimeout(()=>{ \r\n            node.css('display','none');\r\n        },2000);\r\n    }\r\n\r\n    /**\r\n     * 大转盘的转动动画\r\n     */\r\n    jumpAnimation(){ \r\n        let node =  _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#turntable');\r\n      \r\n        _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()(function(){ \r\n            node.addClass('animationJump hit-jump-animation');\r\n            setTimeout(function(){ \r\n                node.removeClass('hit-jump-animation');\r\n            }, 1000);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * 传入相关天窗的node节点显示使用相关的动画\r\n     * @param {object} node \r\n     */\r\n    pupopAnimation(nodeObj){\r\n        let node =  _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()(nodeObj).find('#pupop-bg-box');\r\n        _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()(function(){\r\n            node.addClass('animated bounceInUp');\r\n            setTimeout(function(){\r\n                node.removeClass('bounceInUp');\r\n            }, 1000);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * 添加动画  \r\n     * @param {object} nodeObj 动画的node\r\n     * @param {string} animation 动画的类型\r\n     * @param {number} time //动画的时间\r\n     */\r\n    nodeAnimation(nodeObj,animation,time = 1000,BACK){ \r\n        _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()(function(){ \r\n            nodeObj.addClass(`animated-starts  ${animation}`); \r\n            setTimeout(function(){  \r\n                nodeObj.removeClass(animation);\r\n                if(BACK!=null){\r\n                    BACK();\r\n                }\r\n            }, time);\r\n        });\r\n    }\r\n    //获取指定区间范围随机数，包括lowerValue<=x<=upperValue\r\n    /**\r\n     * 传入取到相关参数\r\n     * @param Min\r\n     * @param Max\r\n     * @returns {*}\r\n     */\r\n    randomFrom(Min, Max) {\r\n        var Range = Max - Min;\r\n        var Rand = Math.random();\r\n        var num = Min + Math.floor(Rand * Range);  //舍去\r\n        return num;\r\n\r\n    }\r\n    /**\r\n     * 看视频的接口\r\n     */\r\n    watchVideosSDK(num,BACKOK=null){\r\n        watchVideosType.changeType = num;\r\n     \r\n        if(BACKOK!=null){\r\n            watchVideosType.watchVideoCallBack = BACKOK;\r\n        }\r\n        console.log('对视频进行拉取的请求')\r\n        //请求视频的播放\r\n        // location.href='qtj://profession/loadCAJVideo'\r\n        // window.location.href=\"qtj://profession/playH5Video?url=\"\r\n        // console.log('thia.watchVideosBtnEvent',this.watchVideosBtnEvent);\r\n        this.watchVideosBtnEvent();\r\n       \r\n    } \r\n    /**\r\n     * 初始化视频的回调\r\n     */\r\n    initVideosSDKBack(){\r\n        //在window上挂在视频看完的回调\r\n        window._videoCallback = function(){\r\n            //回到函数不为空就调取这个函数\r\n            if(watchVideosType.watchVideoCallBack!=null){\r\n                watchVideosType.watchVideoCallBack();\r\n                console.log('视频回到成功',watchVideosType.watchVideoCallBack)\r\n            } \r\n        }\r\n    }\r\n\r\n    /**\r\n     * 增加或者减少体力使用的\r\n     * @param {number} num 这个可以正数  可以负数\r\n     */\r\n    addstrengthNum(num){\r\n        let strengthNum = this.strengthNum;\r\n        strengthNum +=num; \r\n        //检测当前体力值的数量\r\n        if(strengthNum<=0){\r\n            strengthNum = 0;\r\n        }\r\n        this.strengthNum = strengthNum;\r\n        console.log('用户当前的相关体力值发生改变-',num >= 0 ?  '增加了:':'减少了:',Math.abs(num));\r\n    }\r\n    /**\r\n     * 封装使用数据驱动\r\n     * @param {obj} obj 作用域 \r\n     * @param {string} parametern 变量名字\r\n     * @param {number} nun 初始化的数值 \r\n     * @param {function} BACK 每次的改动的回调\r\n     */\r\n    setProperty(obj,parametern,nun,BACK){ \r\n        //玩家的当前的金币数量\r\n        Object.defineProperty(obj,parametern,{\r\n            get(){\r\n                return nun;\r\n            },\r\n            set(vlue){ \r\n                nun= vlue;\r\n                if(BACK!=null){\r\n                    BACK(vlue);\r\n                 }\r\n            }\r\n        }) \r\n    } \r\n    /**\r\n     * 封装的按钮事件 当前的按钮\r\n     * @param {string} _nodeId ;当前node节点id的名字\r\n     * @param {function} BACK \r\n     */\r\n    setBtn(_nodeId,BACK){\r\n        let startStatus={\r\n            transform: 'scale(1.0)'\r\n        }\r\n        //结束的状态\r\n        let targetStatus1={\r\n            transform: 'scale(1.1)'\r\n        }\r\n        let targetStatus2={\r\n            transform: 'scale(0.9)'\r\n        }\r\n        let node = _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()(_nodeId); \r\n        node.click(()=>{\r\n            node.animate(targetStatus1,100,()=>{\r\n                node.animate(targetStatus2,100,()=>{ \r\n                    if(BACK!=null){\r\n                        BACK();\r\n                    }\r\n                    node.animate(startStatus,50,()=>{})\r\n                })\r\n            }) \r\n        }) \r\n    }\r\n    //碰撞检测的方法  \r\n    checkCrash(bodyA,bodyB){ \r\n        bodyA.left -=13;\r\n        // bodyA.top +=110;\r\n\r\n        // bodyB.left -=0;\r\n        // bodyB.top +=110;\r\n\r\n        // bodyA.width = bodyB.width =15;\r\n        // bodyA.height = bodyB.height = 25;\r\n\r\n        bodyA.width = bodyB.width =24;\r\n        return !(bodyA.left + bodyA.width < bodyB.left ||\r\n\r\n            bodyB.left + bodyB.width < bodyA.left ||\r\n\r\n            bodyA.top + bodyA.height < bodyB.top ||\r\n\r\n            bodyB.top + bodyB.height < bodyA.top);\r\n    } \r\n\r\n    /**\r\n     * 设置本地的相关参数  \r\n     * @param {string} key \r\n     */\r\n    setlocalData(){ \r\n        console.log('储存本地的数据1');\r\n        //检查浏览器是不是支出本地储存数据\r\n        if (window.localStorage){\r\n            //主逻辑业务\r\n            //取到时间  换算成秒 方便进行处理检查是不是今天\r\n            let lsstTimeInfo_ = new Date();\r\n            localStorage.lastTime = lsstTimeInfo_;\r\n            //建立储存\r\n            let storage = window.localStorage;\r\n            localStorage.strengthNum = this.strengthNum\r\n            // console.log('storage:',storage);\r\n            let _localStorage = JSON.stringify(localStorage);\r\n            //写入W105SINFO字段\r\n            storage[gameInfo.key] = _localStorage; \r\n            console.log('储存本地的数据2',_localStorage);\r\n        }\r\n    }\r\n    /**\r\n     *取到本地的相关参数\r\n     * @param {string} key \r\n     */\r\n    getlocalData(key){\r\n        // console.log('玩家当前的在提取本地记录'); \r\n        //提取本地的记录-----------------------\r\n        let storage = window.localStorage;\r\n        let info = storage.getItem(gameInfo.key)\r\n        if (info) {\r\n            let userData_ = JSON.parse(info); \r\n           //检测是不是进今天\r\n           if(this.isSameDay(userData_.lastTime,new Date())){\r\n                localStorage = userData_;\r\n                console.log('本地的相关数据是:',localStorage);\r\n           }  \r\n        }  \r\n    }\r\n    /**\r\n     * 检测是不是统一\r\n     * @param {*} timeStampA \r\n     * @param {*} timeStampB \r\n     */\r\n    isSameDay(timeStampA, timeStampB) {\r\n        let dateA = new Date(timeStampA);\r\n        let dateB = new Date(timeStampB);\r\n        return (dateA.setHours(0, 0, 0, 0) == dateB.setHours(0, 0, 0, 0));\r\n    }\r\n\r\n    //**************************跑马灯的需求*********** */\r\n    horseRaceLamp(){  \r\n        let addNUm = -100;\r\n        let fristNum = 0;\r\n        let obj = _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#rewardList-index28-0'); \r\n        \r\n        let initTop={\r\n            top:'0%',\r\n        };  \r\n        let timerNUM = 500;\r\n        var self = this; \r\n        self.index28MakeList(1);\r\n        self.index28MakeList(4); \r\n        obj.animate(initTop,1,function(){ \r\n            self.index28MakeList(2);\r\n            fristNum += addNUm;\r\n            obj.animate({top:`${fristNum}%`},timerNUM,()=>{\r\n                fristNum += addNUm;\r\n                self.index28MakeList(3);\r\n                setTimeout(()=>{\r\n                    obj.animate({top:`${fristNum}%`},timerNUM,()=>{\r\n                        fristNum += addNUm;\r\n                        setTimeout(()=>{\r\n                            obj.animate({top:`${fristNum}%`},timerNUM,()=>{\r\n                                fristNum += addNUm;  \r\n                                setTimeout(()=>{\r\n                                    obj.animate({top:`${fristNum}%`},1,()=>{ \r\n                                        self.horseRaceLamp();\r\n                                    });\r\n                                },1000);\r\n                            });\r\n                        },1000);\r\n                    });   \r\n                },1000);\r\n            });\r\n        }); \r\n    }\r\n    \r\n    //处理文本\r\n    index28NakeDescribe(){\r\n        let text_1 =  '恭喜';\r\n        let getHandNum = Math.ceil(Math.random()*20);\r\n        let text_2 =  gameInfo.phoneHand[getHandNum];\r\n        let listNum = Math.ceil(Math.random()*10000) ;\r\n        if(listNum<1000){\r\n            listNum = 6785;\r\n        }\r\n        let text_3 = '***';\r\n        let getMoneyNum = Math.floor(Math.random()*gameInfo.redMoney.length) ;\r\n        getMoneyNum = gameInfo.redMoney[getMoneyNum];\r\n        let redNumText = '获得'+getMoneyNum;\r\n        return {\r\n            context1:text_1+text_2.toString()+text_3+listNum.toString(),\r\n            context2: redNumText,\r\n        };\r\n    } \r\n    /**\r\n     * 当前是第一个 从而更新相关的信息\r\n     * @param {*} num ;\r\n     */\r\n    index28MakeList(num){\r\n        let context = this.index28NakeDescribe();\r\n        let obj = _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()(`#rewardList-index28-${num}`);\r\n        let content1 = obj.find('#index-context-1');\r\n        let content2 = obj.find('#index-context-2');\r\n        if(num=== 1 ){\r\n    \r\n            content1.text(context.context1);\r\n            content2.text(context.context2);\r\n        }else if(num=== 2){\r\n            content1.text(context.context1);\r\n            content2.text(context.context2);\r\n        }else if(num=== 2){\r\n            content1.text(context.context1);\r\n            content2.text(context.context2);\r\n        }else{\r\n            content1.text(context.context1);\r\n            content2.text(context.context2);\r\n        }\r\n\r\n    }\r\n    /**\r\n     * 大转盘的掉落\r\n     */\r\n    turntableFallDown(){ \r\n        // //左边的\r\n        this.turntableAni_left = new  _TurntableAni_js__WEBPACK_IMPORTED_MODULE_3__[\"TurntableAni\"](100,120,'left-turntable');\r\n        this.turntableAni_left.setLeftMove();\r\n        // // //有右边的\r\n        this.turntableAni_right = new _TurntableAni_js__WEBPACK_IMPORTED_MODULE_3__[\"TurntableAni\"](100,120,'right-turntable');\r\n        this.turntableAni_right.setRightMove();\r\n\r\n        this.showTurntableDoAniPage(false);\r\n    }\r\n    /**\r\n     * 打开掉落的动画\r\n     */\r\n    turntableDoAni(BACK=null){\r\n        //打开动画状态\r\n        this.turntableAni_left.beginAni();\r\n        this.turntableAni_right.beginAni();\r\n\r\n        //将当前的大专篇关闭掉 动画结束再打开\r\n        this.showTurntableBox(false);\r\n        //设置动画的回调\r\n        this.turntableAni_right.AnimationOver(()=>{\r\n            console.log('动画结束了')\r\n            this.showTurntableDoAniPage(false);\r\n            // this.showTurntableBox(true);\r\n            if(BACK){\r\n                BACK();\r\n            }\r\n          \r\n        })\r\n        //打开动画页面\r\n        this.showTurntableDoAniPage(true);\r\n    } \r\n    /**\r\n     * 打开还关闭动画页面\r\n     * @param {boolean} bool \r\n     */\r\n    showTurntableDoAniPage(bool = false){\r\n        if(bool){\r\n            _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#pass-over-ani').css('display','inline'); \r\n        }else{\r\n            _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#pass-over-ani').css('display','none');\r\n        }\r\n    }\r\n    /** */\r\n    showTurntableBox(bool = false){\r\n        let node1 = _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#turntable-box');\r\n        let node2 = _node_modules_zepto_webpack_zepto_js__WEBPACK_IMPORTED_MODULE_0___default()('#turntable-box-T');\r\n        if(bool){ \r\n            node1.css('display','inline');\r\n            node2.css('display','inline');\r\n        }else{\r\n            node1.css('display','none');\r\n            node2.css('display','none');\r\n        }\r\n    }\r\n     /**\r\n     * 埋点的处理  \r\n     * @param {numder} num 3页面曝光  4页面埋点\r\n     */\r\n    sendPonit(num) {\r\n     \r\n        if ( this.countinfoPoint === undefined || this.countinfoPoint === null || this.countinfoPoint === '' ) { \r\n            const envType =  false ? undefined : false;//设置当前的环境 是生产环境还是测试环境\r\n            this.countinfoPoint = new _config_point_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](envType)\r\n        } \r\n        this.countinfoPoint.countinfoPoint(num);\r\n    }\r\n    getURLParameter(){\r\n        var url = location.href;\r\n        // console.log('url:', location.href);\r\n        var theRequest = new Object();\r\n        if (url.indexOf(\"?\") != -1) {\r\n            var str = url.split('?')[1];\r\n            str = str.split('#')[0];\r\n            var strs = str.split(\"&\");\r\n            for (var i = 0; i < strs.length; i++) {\r\n                theRequest[strs[i].split(\"=\")[0]] = unescape(strs[i].split(\"=\")[1]);\r\n\r\n            }\r\n        }\r\n        return theRequest||null;\r\n    }\r\n    /**\r\n     * @param {function} fun 调用函数\r\n     * @param {number} delay 延迟调用时间\r\n     * @param {array} args 剩余参数\r\n     */\r\n    throttle(fun, delay, ...args) {\r\n        let last = null;\r\n        return (...rest) => {\r\n            const now = + new Date();\r\n            let _args = [...args, ...rest];\r\n            if (now - last > delay) {\r\n                fun.apply(null, _args);\r\n                last = now;\r\n            }\r\n        }\r\n    }\r\n    \r\n}\r\nlet _fruitMachine  = new fruitMachine();\r\n// pushHistory(); \r\n// window.addEventListener(\"popstate\", function(e) { \r\n//     　　_fruitMachine.showStandPupop(true);\r\n// }, false); \r\n// function pushHistory() { \r\n// 　　var state = { \r\n// 　　　　title: \"title\", \r\n// 　　　　url: \"#\"\r\n// 　　}; \r\n// 　　window.history.pushState(state, \"title\", \"#\"); \r\n// }\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/index.scss":
/*!************************!*\
  !*** ./src/index.scss ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack:///./src/index.scss?");

/***/ })

/******/ });